<!doctype html>
<html lang="ko" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-react/question/README" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.0.1">
<title data-rh="true">질문 리스트 | Front-end Tech Interview</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://saseungmin.github.io/frontend-tech-interview/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://saseungmin.github.io/frontend-tech-interview/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://saseungmin.github.io/frontend-tech-interview/docs/react/question"><meta data-rh="true" property="og:locale" content="ko"><meta data-rh="true" name="docusaurus_locale" content="ko"><meta data-rh="true" name="docsearch:language" content="ko"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="질문 리스트 | Front-end Tech Interview"><meta data-rh="true" name="description" content="🎈 프론트엔드에서 컴포넌트란? (개인적인 생각)"><meta data-rh="true" property="og:description" content="🎈 프론트엔드에서 컴포넌트란? (개인적인 생각)"><link data-rh="true" rel="icon" href="/frontend-tech-interview/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://saseungmin.github.io/frontend-tech-interview/docs/react/question"><link data-rh="true" rel="alternate" href="https://saseungmin.github.io/frontend-tech-interview/docs/react/question" hreflang="ko"><link data-rh="true" rel="alternate" href="https://saseungmin.github.io/frontend-tech-interview/docs/react/question" hreflang="x-default"><link rel="stylesheet" href="/frontend-tech-interview/assets/css/styles.803d6110.css">
<script src="/frontend-tech-interview/assets/js/runtime~main.76f5c542.js" defer="defer"></script>
<script src="/frontend-tech-interview/assets/js/main.68eb198d.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="본문으로 건너뛰기"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">본문으로 건너뛰기</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/frontend-tech-interview/"><div class="navbar__logo"><img src="/frontend-tech-interview/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/frontend-tech-interview/img/logo.svg" alt="My Site Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Front-end Tech Interview</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/frontend-tech-interview/docs">Questions</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/saseungmin/frontend-tech-interview" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-label="어두운 모드와 밝은 모드 전환하기 (현재 밝은 모드)" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="맨 위로 스크롤하기" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="Docs sidebar" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs">🎉 Intro</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/frontend-tech-interview/docs/TestAndTDD">👉 Test와 TDD에 대한 정리</a><button aria-label="Expand sidebar category &#x27;👉 Test와 TDD에 대한 정리&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs/article">👉 프론트엔드 어머 이건 봐야해!</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs/css">👉 CSS</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs/front-end">👉 Front-end</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs/html">👉 HTML</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/frontend-tech-interview/docs/javascript">👉 JavaScript</a><button aria-label="Expand sidebar category &#x27;👉 JavaScript&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs/liftIO-2021">👉 Functional Programming Conference LiftIO 2021</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/frontend-tech-interview/docs/network">👉 Network</a><button aria-label="Expand sidebar category &#x27;👉 Network&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/frontend-tech-interview/docs/react">👉 React</a><button aria-label="Collapse sidebar category &#x27;👉 React&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/frontend-tech-interview/docs/react/question">질문 리스트</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/react-18">👉 React 18 변경점</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/react-clean-architecture">👉 React Architecture 및 패턴과 관련된 아티클</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/react-fiber-architecture">👉 React Fiber Architecture</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/react-official-docs">React 공식문서 필요한 부분 정리</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/reconciliation">재조정 (Reconciliation)</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/redux-vs-react-query">🤔 Topic: SWR 또는 React Query와 같은 라이브러리가 나타나게 된 배경 및 원인</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/frontend-tech-interview/docs/react/when-to-useMemo-and-useCallback">When to useMemo and useCallback</a></li></ul></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/frontend-tech-interview/docs/typescript">👉 TypeScript</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/frontend-tech-interview/docs/web">👉 Web</a><button aria-label="Expand sidebar category &#x27;👉 Web&#x27;" type="button" class="clean-btn menu__caret"></button></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="Breadcrumbs"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="홈" class="breadcrumbs__link" href="/frontend-tech-interview/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/frontend-tech-interview/docs/react"><span itemprop="name">👉 React</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">질문 리스트</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">이 페이지에서</button></div><div class="theme-doc-markdown markdown"><h1>질문 리스트</h1>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-프론트엔드에서-컴포넌트란-개인적인-생각">🎈 프론트엔드에서 컴포넌트란? (개인적인 생각)<a href="#-프론트엔드에서-컴포넌트란-개인적인-생각" class="hash-link" aria-label="🎈 프론트엔드에서 컴포넌트란? (개인적인 생각)에 대한 직접 링크" title="🎈 프론트엔드에서 컴포넌트란? (개인적인 생각)에 대한 직접 링크">​</a></h2>
<p>리액트 공식 문서에 컴포넌트의 정리를 보면 &quot;컴포넌트를 통해 UI를 재사용 가능한 개별적인 여러 조각으로 나누고, 각 조각을 개별적으로 살펴볼 수 있습니다.&quot;와 같습니다.<br>
<!-- -->이 구절에서 볼 수 있듯이 컴포넌트는 재사용 가능한 개별적인 여러 조각이라고 말할 수 있습니다. 우리는 여기서 컴포넌트는 확장성있고 재사용 가능해야하고 독립적이여야 합니다. 그러기 위해서는 컴포넌트는 단일 책임을 가지는 컴포넌트로 구성되어야 합니다. 이러한 컴포넌트들은 테스트하기 좋고 가독성도 좋습니다. 우리가 이러한 재사용 가능한 컴포넌트를 사용하면 DRY 원칙을 지키며 중복 없는 코드를 작성할 수 있습니다.</p>
<p>이때 API를 호출하는 로직이 포함되어있거나 비즈니스 로직이 포함되어 있는 경우에는 좀 더 유연하고 융통성 있는 컴포넌트를 만들어야 합니다. 이러한 컴포넌트를 만들 때 패턴들의 기본적인 베이스는 제어의 역전이 발판으로 되어 있는데, 해당 컴포넌트에게 제어권을 넘겨주고 흐름에 맞게 통제 또는 해당 로직을 구현하고 이 흐름에 대한 호출은 외부 라이브러리가 해주는 방식으로 간단한 API를 만들 수 있으며 이렇게 하면 재사용 가능한 컴포넌트를 만들 수 있습니다.</p>
<p>제가 흔히 많이 사용하고 있는 custom hook도 예를 들 수가 있는데 이 custom hook을 생성하여 사용하면 비즈니스 로직을 분리할 수 있으며 우리는 이 custom hook으로 필요한 컴포넌트에 맞게 사용할 수 있습니다. 따라서 제어권은 해당 컴포넌트가 가지고 있고 해당 통제권을 넘겨주어 해당 컴포넌트에서 직접 로직을 호출하는 것이 아닌 컴포넌트 밖의 custom hook에서 호출하게 하여 관심사를 분리함으로써 컴포넌트를 재사용할 수 있습니다.<br>
<!-- -->여기서 주의해야할 점은 결국 모든 원칙은 트레이드오프임으로 관심사에 따른 분리와 재사용성의 확대를 위해 제어 위임을 적절하게 하고 너무 어렵지 않게 사용성도 높이는 그 사이의 최적을 찾아내는건 각자의 개발자의 몫이라고 생각합니다.</p>
<p>잘 설계된 컴포넌트는 (외부로 제어를 위임하여) 재사용 가능하고 확장 가능한 단일 책임 원칙을 따르는 테스트 용이한 컴포넌트라고 생각합니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-리액트-hooks의-장점">🎈 리액트 Hooks의 장점<a href="#-리액트-hooks의-장점" class="hash-link" aria-label="🎈 리액트 Hooks의 장점에 대한 직접 링크" title="🎈 리액트 Hooks의 장점에 대한 직접 링크">​</a></h2>
<p>Hooks를 사용하면 로직의 재사용이 가능하고 관리가 쉽다는 것입니다. 함수 안에서 다른 함수를 호출하는 것으로 새로운 hook을 만들어 볼 수 있습니다. 기존의 class component는 여러 단계의 상속으로 인해 전반적으로 복잡성과 오류 가능성을 증가시켰습니다. 하지만 function component에 hooks를 도입하면서 class component가 가지고 있는 기능을 모두 사용할 수 있음은 물론이고 기존 class component 복잡성, 재사용성의 단점들까지 해결됩니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-class-component와-function-component의-차이점에-대해서-설명하세요">🎈 Class Component와 Function Component의 차이점에 대해서 설명하세요.<a href="#-class-component와-function-component의-차이점에-대해서-설명하세요" class="hash-link" aria-label="🎈 Class Component와 Function Component의 차이점에 대해서 설명하세요.에 대한 직접 링크" title="🎈 Class Component와 Function Component의 차이점에 대해서 설명하세요.에 대한 직접 링크">​</a></h2>
<p>class component는 여러 단계의 상속으로 이루어져 있습니다. 그리하여 복잡성과 오류 가능성을 증가시켰습니다. 결국 class component는 테스트하기 어렵습니다. 이로 인해 Function Component가 탄생하게 되었고, class component는 라이플 사이클을 가지면 이로인해 각각 생명주기 메소드에 대해 알고 있어야 합니다. 또한, class Component에서 this 사용은 어려움을 느낄 수도 있습니다. 하지만 Function Component는 이러한 기능을 hook을 사용하여 생명주기에 원하는 동작을 하게 합니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-virtual-dom이-무엇인가요-virtual-dom이-좋은-이유에-대해서-설명하세요">🎈 virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명하세요.<a href="#-virtual-dom이-무엇인가요-virtual-dom이-좋은-이유에-대해서-설명하세요" class="hash-link" aria-label="🎈 virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명하세요.에 대한 직접 링크" title="🎈 virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명하세요.에 대한 직접 링크">​</a></h2>
<p>virtual DOM은 실제 DOM의 변화를 최소화 시켜주는 역할을 합니다. virtual DOM을 사용하는 이유는 효율성 때문입니다. virtual DOM을 활용하면 실제 DOM을 바꾸는 것보다 시간 복잡도가 낮아집니다. 만약 HTML 파일에 20개의 변화가 생기면 과정 역시 20회가 이루어 집니다. 하지만 virtual DOM은 변화된 부분만 가려내여 실제 DOM에 전달하기에 실제 DOM은 1회로 인식하여 단 한번만의 렌더링 과정만 거치게 됩니다.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="공식-문서">공식 문서<a href="#공식-문서" class="hash-link" aria-label="공식 문서에 대한 직접 링크" title="공식 문서에 대한 직접 링크">​</a></h3>
<p>가상 DOM(VDOM)은 UI의 이상적인 또는 &quot;virtual&quot; 표현이 메모리에 유지되고 ReactDOM과 같은 라이브러리에 의해 &quot;real&quot; DOM과 동기화되는 프로그래밍 개념입니다. 이 프로세스를 reconciliation(재조정) 이라고 합니다 .</p>
<p>이 접근 방식은 React의 선언적 API를 가능하게 합니다.: React에 UI를 원하는 상태를 지정하면 DOM이 해당 상태와 일치하는지 확인합니다. 이러한 방식은 앱 구축에 사용해야 하는 어트리뷰트 조작, 이벤트 처리, 수동 DOM 업데이트를 추상화합니다.</p>
<p>“virtual DOM”은 특정 기술이라기보다는 패턴에 가깝기 때문에 사람들마다 의미하는 바가 다릅니다. React의 세계에서 “virtual DOM”이라는 용어는 보통 사용자 인터페이스를 나타내는 객체이기 때문에 React elements와 연관됩니다. 그러나 React는 컴포넌트 트리에 대한 추가 정보를 포함하기 위해 “fibers”라는 내부 객체를 사용합니다. 또한 React에서 “virtual DOM” 구현의 일부로 간주할 수 있습니다.</p>
<blockquote>
<p><a href="https://reactjs.org/docs/faq-internals.html" target="_blank" rel="noopener noreferrer">공식 문서</a></p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-웹-성능-향상을-위해-최적화를-해-본-경험이-있나요-혹은-usememo와-usecallback-메소드를-활용해-최적화하는-원리에-대해서-설명하세요">🎈 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요.<a href="#-웹-성능-향상을-위해-최적화를-해-본-경험이-있나요-혹은-usememo와-usecallback-메소드를-활용해-최적화하는-원리에-대해서-설명하세요" class="hash-link" aria-label="🎈 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요.에 대한 직접 링크" title="🎈 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요.에 대한 직접 링크">​</a></h2>
<p><code>useMemo</code>와 <code>useCallback</code>은 성능 최적화를 위해서 사용되는 Hook입니다. 이 때, <code>useMemo</code>는 특정 결과 값을 재사용하는 반면에 <code>useCallback</code>은 특정함수를 새로 만들지 않고 재사용하고 싶을 때 사용합니다. 이 둘은 dependency 리스트를 이용하여 그 중 하나가 변경이 되면 결과에 대해 변경됩니다.</p>
<blockquote>
<p><a href="https://github.com/saseungmin/frontend-tech-interview/blob/main/react/when-to-useMemo-and-useCallback.md" target="_blank" rel="noopener noreferrer">When to <code>useMemo</code> and <code>useCallback</code></a></p>
</blockquote>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-react-concurrent-mode">🎈 React Concurrent Mode<a href="#-react-concurrent-mode" class="hash-link" aria-label="🎈 React Concurrent Mode에 대한 직접 링크" title="🎈 React Concurrent Mode에 대한 직접 링크">​</a></h2>
<p>자바스크립트는 싱글스레드 기반 언어이다보니 동시에 처리가 불가능합니다. 그래서 React는 자바스크립트이고 따라서 동일한 제한 사항에 묶여있습니다. 현재로서는, React가 <a href="https://ko.reactjs.org/docs/reconciliation.html" target="_blank" rel="noopener noreferrer">재조정(Reconciliation)</a> 과정을 한번 시작하면, 이 과정이 완전히 끝나기 전까지는 이를 멈출 수 없습니다. 그러면 브라우저의 메인 UI 스레드는 사용자 입력을 받는 등의 다른 작업을 실행할 수 없게 됩니다.</p>
<p>그래서 concurrent mode가 탄생하게 되었는데 여러 작업을 동시에 처리하도록 하는 방식인데, 실제로는 동시로 작업이 수행되지는 않습니다. 전환이 빠르기 떄문에 그렇게 보이는 것입니다. 그래서 여러 작업을 작은 단위로 나눈뒤 그 작업들 간의 우선순위를 정해서 그 작업을 수행하는 방식입니다.</p>
<p>Concurrent mode를 사용하면 사용자 경험에서 아주 중요한 역할을 합니다. 사용자가 필요로하는 중요한 부분을 우선순위를 높게하고 불필요한 부분에는 delay를 걸어주어 사용자경험을 향상시킬 수 있습니다.</p>
<ul>
<li><a href="https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react" target="_blank" rel="noopener noreferrer">https://reactjs.org/blog/2022/03/29/react-v18.html#what-is-concurrent-react</a></li>
<li><a href="https://velog.io/@cadenzah/react-concurrent-mode" target="_blank" rel="noopener noreferrer">https://velog.io/@cadenzah/react-concurrent-mode</a></li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-hydrate란">🎈 Hydrate란?<a href="#-hydrate란" class="hash-link" aria-label="🎈 Hydrate란?에 대한 직접 링크" title="🎈 Hydrate란?에 대한 직접 링크">​</a></h2>
<p>Hydrate는 SSR에서 사용되는 개념입니다. SSR의 경우 pre-rendering를 통해 완성된 HTML을 클라이언트에게 전달합니다. 이렇게 서버에서 렌더링된 정적 페이지를 클라이언트에게 보내고, react는 번들링된 JavaScript 코드를 클라이언트에게 보냅니다. 클라이언트는 전달받은 HTML과 JS코드를 매칭하는 Hydrate를 수행합니다. Hydrate란 전송받은 JavaScript들이 이전에 보내진 HTML DOM  요소 위에서 한번 더 렌더링 하게 되면서 각각 자기 자리를 찾아가며 매칭되는 것입니다. Hydrate 후에는 클릭과 같은 이벤트나 모듈들이 적용되어 사용자 조작이 가능해집니다.</p>
<p>즉, Hydrate는 클라이언트 측 JavaScript가 정적 호스팅 또는 서버 측 렌더링을 통해 전달되는 정적 HTML 요소에 이벤트 핸들러를 첨부하여 동적 웹 페이지로 변환하는 기술입니다.</p>
<p>React 18 이전에는 한 번 hydration이 시작되면 전체 트리가 완전히 hydration이 되기 전까지는 유저는 hydration이 불필요한 다른 영역과 상호작용을 할 수 없었습니다. 하지만 react 18 버전에서 suspense를 사용한 concurrent mode를 사용할 수 있게 되면서 필요한 부분만 hydration이 가능하며, 기존에 hydration을 하기 위해서는 모두 불러와야하는 문제도 lazy를 사용한 코드 스플리팅으로 해결할 수 있게 되었습니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-react-query">🎈 React Query<a href="#-react-query" class="hash-link" aria-label="🎈 React Query에 대한 직접 링크" title="🎈 React Query에 대한 직접 링크">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="staletime-vs-cachetime"><code>staleTime</code> vs <code>cacheTime</code><a href="#staletime-vs-cachetime" class="hash-link" aria-label="staletime-vs-cachetime에 대한 직접 링크" title="staletime-vs-cachetime에 대한 직접 링크">​</a></h3>
<p><code>staleTime</code>은 데이터가 fresh 상태에서 stale 상태로 변경되는데 걸리는 시간입니다. 기본값은 0분으로 즉시 변경됩니다. fresh 상태일 때는 쿼리 인스턴스가 새롭게 mount 되어도 네트워크 fetch가 일어나지 않습니다. 또한, <code>staleTime</code>이 지나지 않았다면 unmount 후 mount 되어도 fetch가 일어나지 않습니다.</p>
<p><code>cacheTime</code>은 데이터가 inactive(비활성) 상태일 때 캐싱된 상태로 남아있는 시간으로 기본값은 5분입니다. 쿼리 인스턴스가 unmount 되면 데이터는 inactive 상태로 변경되며, 캐시는 <code>cacheTime</code>만큼 유지됩니다. <code>cacheTime</code>이 지났을 경우에는 가비지 컬렉터 수집 대상이 됩니다. 만약 <code>cacheTime</code>이 지나기 전에 쿼리 인스턴스가 다시 mount 되면, 데이터를 fetch하는 동안 캐시 데이터를 보여줍니다.</p>
<blockquote>
<p><a href="https://tanstack.com/query/latest/docs/react/guides/caching" target="_blank" rel="noopener noreferrer">https://tanstack.com/query/latest/docs/react/guides/caching</a></p>
</blockquote>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="isloading-vs-isfetching"><code>isLoading</code> vs <code>isFetching</code><a href="#isloading-vs-isfetching" class="hash-link" aria-label="isloading-vs-isfetching에 대한 직접 링크" title="isloading-vs-isfetching에 대한 직접 링크">​</a></h3>
<p><code>isFetching</code>은 데이터가 fetch될 때 <code>true</code>일 뿐만 아니라, 캐싱 데이터가 있어서 백그라운드에서 fetch 되더라도 <code>true</code>입니다.<br>
<code>isLoading</code>은 캐싱된 데이터가 없을 때 fetch 경우에만 <code>true</code>입니다.</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="-reference">🎈 Reference<a href="#-reference" class="hash-link" aria-label="🎈 Reference에 대한 직접 링크" title="🎈 Reference에 대한 직접 링크">​</a></h2>
<ul>
<li><a href="https://velog.io/@ye-ji/React-%EC%98%88%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8" target="_blank" rel="noopener noreferrer">https://velog.io/@ye-ji/React-%EC%98%88%EC%83%81-%EB%A9%B4%EC%A0%91-%EC%A7%88%EB%AC%B8-%EB%A6%AC%EC%8A%A4%ED%8A%B8</a></li>
</ul></div><footer class="theme-doc-footer docusaurus-mt-lg"><div class="theme-doc-footer-edit-meta-row row"><div class="col"><a href="https://github.com/saseungmin/frontend-tech-interview/tree/main/docs/react/question/README.md" target="_blank" rel="noopener noreferrer" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_Z9Sw" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>페이지 편집</a></div><div class="col lastUpdated_vwxv"></div></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="문서 페이지"><a class="pagination-nav__link pagination-nav__link--prev" href="/frontend-tech-interview/docs/react"><div class="pagination-nav__sublabel">이전</div><div class="pagination-nav__label">👉 React</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/frontend-tech-interview/docs/react/react-18"><div class="pagination-nav__sublabel">다음</div><div class="pagination-nav__label">👉 React 18 변경점</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#-프론트엔드에서-컴포넌트란-개인적인-생각" class="table-of-contents__link toc-highlight">🎈 프론트엔드에서 컴포넌트란? (개인적인 생각)</a></li><li><a href="#-리액트-hooks의-장점" class="table-of-contents__link toc-highlight">🎈 리액트 Hooks의 장점</a></li><li><a href="#-class-component와-function-component의-차이점에-대해서-설명하세요" class="table-of-contents__link toc-highlight">🎈 Class Component와 Function Component의 차이점에 대해서 설명하세요.</a></li><li><a href="#-virtual-dom이-무엇인가요-virtual-dom이-좋은-이유에-대해서-설명하세요" class="table-of-contents__link toc-highlight">🎈 virtual DOM이 무엇인가요? virtual DOM이 좋은 이유에 대해서 설명하세요.</a><ul><li><a href="#공식-문서" class="table-of-contents__link toc-highlight">공식 문서</a></li></ul></li><li><a href="#-웹-성능-향상을-위해-최적화를-해-본-경험이-있나요-혹은-usememo와-usecallback-메소드를-활용해-최적화하는-원리에-대해서-설명하세요" class="table-of-contents__link toc-highlight">🎈 웹 성능 향상을 위해 최적화를 해 본 경험이 있나요? 혹은 useMemo와 useCallback 메소드를 활용해 최적화하는 원리에 대해서 설명하세요.</a></li><li><a href="#-react-concurrent-mode" class="table-of-contents__link toc-highlight">🎈 React Concurrent Mode</a></li><li><a href="#-hydrate란" class="table-of-contents__link toc-highlight">🎈 Hydrate란?</a></li><li><a href="#-react-query" class="table-of-contents__link toc-highlight">🎈 React Query</a><ul><li><a href="#staletime-vs-cachetime" class="table-of-contents__link toc-highlight"><code>staleTime</code> vs <code>cacheTime</code></a></li><li><a href="#isloading-vs-isfetching" class="table-of-contents__link toc-highlight"><code>isLoading</code> vs <code>isFetching</code></a></li></ul></li><li><a href="#-reference" class="table-of-contents__link toc-highlight">🎈 Reference</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">Docs</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/frontend-tech-interview/docs/article">Questions</a></li></ul></div><div class="col footer__col"><div class="footer__title">Community</div><ul class="footer__items clean-list"></ul></div><div class="col footer__col"><div class="footer__title">More</div><ul class="footer__items clean-list"><li class="footer__item"><a href="https://github.com/saseungmin" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 saseungmin. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>