# 🍬 Test와 TDD에 대한 정리

## 🍭 함께 자라기

### P.73
테스트 주도 개발(TDD)을 잘하려면 앞에서 말한 동적인 균형 맞추기를 잘해야 한다. 이걸 잘하면 지속적으로 몰입을 경험할 수 있고 실력이 일신우일신할 수 있다.

#### 지루함을 느끼는 경우: 실력 낮추기
작업의 난이도는 그대로 두고 실력을 낮추는 전략이다. 프로그래머의 예로 들자면, 평상시 즐겨 쓰던 보조 도구를 일부러 안 쓰는 것이다. 디버거를 늘 쓰는 경우 디버거를 안 쓰는 것이다.   

이렇게 난이도와 실력이 잘 맞아 들어가기만 하면 의도적 수련이 될 수 있다.

#### 지루함을 느끼는 경우: 난이도 높이기
실력은 그대로 두고 난이도를 높이는 전략이다. 흔하게 쓰는 방법은 자기에게 요구되는 수준을 더 높게 여기는 것이다. 하루 만에 개발하라고 주어진 업무인데 지루한 느낌이 드니 한 시간 만에 할 수 있는 방법을 고안해 보기, 평소 코드를 검토할 때 버그를 시간당 하나 찾았다면 오늘은 두 개 찾기, 익숙한 작업을 새로운 언어로 진행해 보기 등.   
보통 자신의 업무를 개선하는 일로 리팩터링을 하거나 자동화 테스트를 달거나, 혹은 자신만의 도구를 개발하거나 하는 것들도 있다.   

#### 불안함을 느끼는 경우: 실력 높이기
실력을 높여 몰입 영역으로 들어가는 방법이다. 장기적으로 실력을 높이는 방법은 책을 보거나 스터디에 참가하거나 교육을 듣거나 등등. 하지만 지금 당장 불안함을 느끼고 있다면 어떻게 해야 하는가가 문제이다. 크게 보면 사회적 접근과 도구적 접근, 내관적 접근 세 가지가 가능하다.   

사회적 접근은, 나보다 뛰어난 전문가의 도움을 얻는 것이다. 잘하는 사람한테 가서 짝 프로그래밍을 해달라고 부탁하거나 IRC(인터넷 체팅)에서 전문가의 도움을 얻는 것도 괜찮은 방법이다.   

도구적 접근은 다른 도구의 도움을 받는 것이다. 내 능력을 확장시켜 줄 수 있는 도구들을 찾아 쓰면 된다.   

내관적 접근은 비슷한 일을 했던 경험을 머릿속에서 되살려 보는 것이다. 그때 그 일을 어떻게 했는지 떠올려 보면서 비유적으로 문제를 해결한다. 보통 이런 과정을 거치면 자기효용감이 증대하면서 스스로 인식하는 자기 실력이 향상되기 쉽고, 결과적으로 몰입 영역으로 들어가기 좋다.   

#### 불안함을 느끼는 경우: 난이도 낮추기
불안함을 느낄 때 난이도를 낮춰서 몰입 영역으로 들어가는 전략이다.   

간단하면서 효과적인 방법은 자신이 맡은 일의 가장 간단하면서 핵심적인 결과물, 즉 아기 버전(혹은 0.0.1 버전)을 첫 번째 목표로 삼는 것이다. 애자일에서 말하는 WTSTTCPW(What's The Simplest Thing That Could Possibly Work?, 동작할 수도 있는 가장 간단한 건 뭘까?)와 같다.

### P.98
TDD 교육을 통해 사람들이 기대하는 과정은 보통 이럴 것이다.   

1. TDD를 제대로 이해하고 조직에 돌아간다.
2. 나 스스로 TDD를 제대로 실천해서 객관적 성과를 낸다.
3. TDD가 좋다고 사람들을 설득한다.
4. TDD를 가르쳐 준다.
5. 모두가 TDD를 열심히 한다.
6. 좋은 성과를 낸다.

여기에서 보통 문제가 되는 부분은 3, 4, 5, 6번이다. 그리고 1과 2를 잘한다고 해서 3번 이후가 꼭 쉬어지는 것이 아니다. 하지만 교욱에서는 통상 1번에만 집중을 한다. 이럴 경우, 실무로 돌아갔을 때 흔히 접하는 문제는 예컨대 다음과 같다.   

- 회사로 돌아가서 실무에 적용하려고 하는데 상사나 동료의 지원 없이 추가적으로 일을 하려니, 시간이 모자라 계속 미루게 되어 결국 적용하지 못한다.
- 팀원, 팀장들에게 전파 교육을 하려 하지만 팀원, 팀장들 가운데 몇몇은 추가 업무를 왜 하는지 필요성도 못 느끼는 상태에서 강제로 해야 한다는 스트레스를 받아서 부작용이 생긴다(그래서 결과적으로 해당 기법은 실무에 써먹을 수 없다는 평가가 나온다).
- 배운 것을 팀 내에서는 열심히 적용했으니 지원해주는 임원이 없어 확대하는 데 실패하고, 조직 내에서는 한 팀의 별난 문화로 치부되어 실행 범위가 축소된다.
- 배운 대로 팀에서 실천했더니 "다른 부서는 그런 거 없이도 잘하는데 너희는 왜 그런 거 하면서 제때 아웃풋이 안 나오냐"며 이해할 수 없다고 말하는 상사나 협력 팀의 리더와 갈등을 겪는다.
- 기술적으로 어떻게 해야 할지 모르겠는데, 주변에 물어볼 사람이 없어 인터넷 검색하느라 몇 시간씩 보낸다. 하지만 결국 원하는 정보를 찾지 못해서 적용을 포기한다.
- 회사에서는 여력이 없어 배운 것을 집에서 시도해 보려 했더니, 가족들의 여러 요구로 인해 집중할 수 없어 화를 내거나, 가족의 요구대로 하느라 내가 할 일은 시작도 못하거나, 그냥 포기하고 잠을 자게 된다.

이런 문제들은 보통 **사회적 측면**에 대한 것이다. 뭘 하던지 나 혼자가 아니라 항상 누군가가 등장하고, 일의 성패에 다른 사람이 관련되어 있기 때문이다.   

아무리 기술적인 실천법이라고 해도 그 기술은 사회적 맥락 속에서 실천되어야 하며 그 기술의 성공을 위해서는 **사회적 자본**과 **사회적 기술**이 함께 필요하다.   

하지만 안타깝게도 현실에서는 **팀원들이 맘에 안 들고, 그들도 나를 맘에 들어 하지 않는 상황, 즉 사화적 맥락이 나쁜 상황에서 타개책으로 TDD의 기술적 측면에만 매몰되는 경우**가 있다. 사실 그런 상황에서는 무엇을 골라도 실패가 보장되어 있다.

다시 한번 반복한다.**어떤 기술적 실천법이라도 그걸 현실에서 적용하기 위해서는 사회적 자본과 기술이 필요**하다. 설사 나 혼자 하는 실천법이라도 해도 말이다.   

TDD 도입에 실패하는 경우, 무엇이 병목이었나를 살펴보면 사람들이 TDD의 기술적 내용을 잘 몰라서보다도 TDD를 도입하는 데에 필요한 **사회적 자본**과 **사회적 기술**이 없어서가 훨씬 더 많았다. 그렇기 때문에 어떤 기술적 지식을 전달한다고 해도 그것을 사회적 맥락 속에서 가르치고 경험하게 해야 한다. 사회적 기술에는 도움받기, 피드백 주고받기, 영향력 미치기, 가르치고 배우기, 위임하기 등이 있다.   

## 🍭  클린 애자일

### P.130 테스트 주도 개발
많은 프로그래머가 애자일을 시도할 때 기술 실천 방법은 빼놓는다. 기술 실천 방법이야말로 애자일의 진짜 핵심이기 떄문이다. TDD와 리팩터링, 단순한 설계, 심지어 짝 프로그래밍도 없다면, 애자일은 원래 의도와는 달리 쓸모없는 빈 껍데기가 되고 만다.   

테스트 주도 개발은 프로그래머의 복식 부기라고 할 수 있다. 구현해야하는 동작을 두 번씩 입력한다. 한 번은 테스트로, 그리고 한 번은 이 테스트를 통과하게 만드는 제품 코드로 말이다. 두 번의 입력은 서로 딱 맞아야 한다.   

TDD를 공부할 떄, 기능을 한 번에 하나씩만 추가한다. 실패하는 테스트 형태로 먼저 하나 추가하고, 이 테스트를 통과하게 만드는 제품 코드 형태로 다시 추가한다. 이렇게 하면 오류를 빠르게 찾을 수 있다.

#### TDD의 세 가지 규칙
1. 해당 코드가 없어서 실패하는 테스트 코드를 쓰기 전에 제품 코드를 먼저 쓰면 안 된다.
2. 테스트 코드를 쓸 때는 실패하도록 만들기 위해 필요한 것보다 더 많이 쓰면 안 된다. 컴파일 실패도 실패로 간주한다.
3. 실패하는 테스트를 통과시키기 위해 필요한 코드보다 더 많은 제품 코드를 쓰면 안 된다.

이 세 가지 규칙을 잘 지킨다면 특정 순간에 한 명을 고른다. 이 프로그래머가 작업하던 코드는 아무리 길어도 1분 전까지는 실행 가능했고, 테스트를 모두 통과했다. 누구를 고르더라도, 어느 시점에 고르더라도 상관없다. 아무리 길어도 1분 전까지는 모든 것이 작동했다. 그렇기 떄문에 쉽게 원인을 알아낼 수 있다.   

디 버깅에 많은 시간을 쓴다는 것은 언제나 그만큼 버그가 많다는 것이다. 테스트 주도 개발을 하면 디버거를 쓸 일이 별로 없기 때문에 디버거에 익수해질 수가 없다.

#### 문서화
이 세 가지 규칙을 따르다보면 만들어지는 테스트는 전체 시스템의 코드 예제가 된다. API 함수를 어떻게 부르는지 알고 싶다면 테스트를 보면 된다. 테스트는 이 함수를 호출하는 모든 방법을 보여 주고, 이 함수가 던지는 모든 예외를 처리하는 방법을 보여 줄 것이다.   

테스트는 테스트하는 시스템을 설명하는 문서의 한 형태다. 이 문서는 프로그래머가 능숙하게 구사하는 언어로 쓰여 있다. 전혀 모호하지 않고, 규칙이 정해져 있어서 실행할 수 있을 정도다. 프로그래머에게 완벽한 형식의 문서가 있다면, 코드 형태일 것이다. 테스트가 바로 그렇다.   

더 좋은 것은 테스트 자체만으로는 시스템을 만들지 못한다는 것이다. 테스트끼리는 서로 묶여 있지 않다. 테스트 간에는 의존성도 없다. 각 테스트는 시스템 중 작은 부분의 동작을 설명하는 작고 독립적인 코드 조각일 뿐이다.

#### 재미
제품을 다 만든 이후에 테스트를 작성해 본 적이 있다면, 재미없는 일이라는 것을 알 것이다. 잘 작동하는 것을 알고 있으니 재미가 없다.   

세 가지 규칙을 따라서 테스트를 먼저 작성하면 재미있다. 테스트 하나가 모두 도전이다. 테스트를 통과하게 만들 때마다 작은 성공을 거두는 것이다. 세 가지 규칙을 따른다면 작업 과정은 작은 도전과 성공의 연속이 된다.   

#### 완벽함
사후 테스트 추가는 이미 손으로 테스트해 봐서 잘 작동한다는 것을 알고 있지만, 의무감에 테스트를 쓰고 있을 것이다. 테스트를 추가할 때마다 테스트가 통과하는 것은 당연한 일이다.   

그러다 보면 테스트를 만들기 힘든 경우를 만나게 될 것이다. 테스트를 만들기 힘든 이유는 테스트 가능 여부를 생각하지 않으면서 코드를 작성하고, 설계할 때도 테스트를 고려하지 않았기 때문이다. 이 코드의 테스트를 만들려면 결합된 곳을 몇 군데 깨고, 추상화를 몇 군데 하고, 함수 호출과 인자 몇 개를 이리저리 옮겨야 할 거 같다. 결국 코드의 구조을 뜯어고쳐야 한다. 이미 코드가 잘 작동하는데 굳이 고치려하니 왠지 일이 더 커 보인다.   

일정은 빡빡하고, 더 급한 일이 많이 기다리고 있다. 일단 테스트는 저리 치워놓자. 테스트는 굳이 필요하지 않다거나, 나중에 돌아와서 다시 작성하면 된다고 자기 합리화를 한다. 이렇게 테스트에 구멍을 남겨놓게 되는 것이다.    

테스트가 통과한다고 해서, 이것을 근거로 내릴 수 있는 결정은 없다. 테스트 통과로 얻은 정보는 테스트가 깨지지 않았다는 것뿐이다. 불완전한 테스트 묶음으로는 아무런 결정은 할 수 없다. 하지만 세 가지 규칙을 잘 따랐다면, 모든 제품 코드는 테스트를 통과하게 만들려고 쓴 것이다. 따라서 테스트 묶음이 아주 완벽할 것이다. 테스트가 통과했다면 결정을 내릴 수 있다. 그 결정은 바로 "배포"다.   

세 가지 규칙을 따르면 아주 와벽한 테스트 묶음이 생길 것이다. 하지만 아마 100% 완벽하지는 않을 것이다. 사실 세 가지 규칙을 따르는 것이 현실적이지 않은 상황이 있기 때문이다. 아무리 성실하게 세 가지 규칙을 따르더라도 100% 완벽한 테스트 묶음이 만들어지지는 않는다. 하지만, 배포를 위해 꼭 100%의 완벽함이 필요한 것은 아니다. 커버리지가 90%대 후반 정도면 충분할 것이다. 그리고 이 정도는 당연히 달성할 수 있다.

> 나는 배포 결정을 내릴 수 있을 만큼 완벽한 테스트 묶음을 만들어 왔고, 다른 사람들이 하는 것도 봐 왔다. 이런 사례에서도 커버리지는 100%가 되지 않았다. 하지만 배포 결정을 내리기 충분했다.
> - 테스트 커버리지는 팀 내부용 지표이지 관리 지표가 아니다. 관리자는 아마 이 숫자가 어떤 의미인지 제대로 알지도 못할 것이다. 관리자는 테스트 커버리지를 목표나 목적으로 삼아서는 안 된다. 테스트 커버리지는 팀의 테스트 전략을 확인하기 위해서만 사용해야 한다.
> - 커버리지가 낮다고 빌드에 실패한 것으로 보아서는 안 된다. 이렇게 하면, 프로그래머는 커버리지를 높이기 위해 단언문도 없이 테스트를 넣어 버릴 것이다. 코드 커버리지는 코드와 테스트에 대한 깊은 지식이 있어야 이해할 수 있는 복잡한 주제다. 절대 관리용 지표로 삼아서는 안 된다.

#### 설계
테스트를 먼저 쓰면 테스트하기 힘든 함수는 쓸 수가 없다. 테스트를 먼저 쓰기 때문에 테스트하기 쉬운 설계가 나오는 것은 당연하다. 어떻게 함수를 테스트하기 쉽게 유지할 수 있을까? 결합을 끊고 분리하면 된다. 사실 테스트할 수 있다는 것은 분리했다는 것과 같은 뜻이다.   

전체 시스템에 모두 테스트가 있을 것이므로, 전체 시스템이 잘 분리되어 있을 것이다. 이 세 가지 규칙이 훨씬 더 잘 분리된 설계를 하도록 만든다.

#### 용기
TDD를 하는 진정한 이유는 용기이다.    

리팩토링시 코드를 두려워하게 된다. 코드를 건드리는 것을 두려워하고, 코드가 망가뜨릴 때 당신에게 벌어질 일을 두려워한다. 그래서 코드를 정리하는 데 실패한다. 코드를 개선하는 데 실패한다. 이리저리 결합이 생기고, 중복인 코드가 계속 추가될 것이다. 그렇기 때문에 작업에 걸리는 시간은 기하급수적으로 증가할 것이다.   

결국 관리자는 좌절할 것이고 시스템 밑바닥에서부터 다시 만들자는 프로그래머들의 요구를 수용하고 만다. 그리고 역사는 반복될 것이다.   

완벽한 테스트 묶음이 있으면 코드를 고치는 두려움이 사라진다. 코드를 정리하는 두려움이 사라진다. 따라서 코드를 정리할 것이다. TDD는 용기를 준다. 용기가 있어야 코드를 깨끗하고 정돈된 상태로 관리할 수 있다.

### P.140 리팩터링
리팩터링은 코드의 구조를 개선하면서 동작은 바꾸지 않는 실천 방법이다. 프로그램의 동작은 테스트로 정의해야 한다. 다시 말해서, 테스트를 꺠먹지 않으면서 이름이나 클래스, 함수, 표현식을 변경하는 것이다. 동작에 영향을 주지 않으면서 시스템 구조를 개선한다.   

당연히 리팩터링은 TDD와 밀접한 관련이 있다. 두려움 없이 코드를 리팩터링하려면, 무언가 꺠 먹지 않았다는 확신을 얻을 수 있는 테스트 묶음이 필요하다.   

리팩터링 과정에서 하는 일은 사소하게는 코드를 조금 더 보기 좋게 만드는 것부터 근본적인 구조 변경까지 다양하다. 이 모든 일이 일어나는 동안, 테스트는 계속해서 통과해야 한다.

#### 빨강/초록/리팩터링
본질적으로 리팩터링은 TDD의 세 가지 규칙을 반복함으로써 이루어진다.   
리팩터링에서는 빨강/초록/리팩터링 주기라고 부른다.   

1. 먼저, 실패하는 테스트를 만든다.
2. 그리고 이 테스트를 통과하게 만든다.
3. 그리고 코드를 정리한다.
4. 1단계로 돌아간다.

여기서 핵심은 프로그래밍이라는 과업을 작동하는 코드를 쓰는 것과 정리하기라는 두 가지 다른 측면으로 분리한 것이다. 두 가지 측면을 동시에 다루는 것은 어려울 수밖에 없다. 그러므로 두 가지 측면을 두 가지 다른 활동으로 분리한다.   

쉽게 말하면, 깨끗한 코드를 만드는 것을 고사하고, 그저 테스트를 통과하게 만드는 것만으로도 충분히 어렵다. 그러니 먼저 코드가 작동하게 만드는 데만 집중하자. 일단 머리에 떠오르는 어떤 지저분한 수단이든 동원해서 말이다. 그리고 일단 작동하면, 테스트는 통과했을 것이고, 이제 그동안 만든 지저분한 것들을 정리하자.   

이렇게 보면 리팩터링이 연속적인 과정이라는 것이 명확해진다. 따로 일정을 잡고 하는 작업이 아니라는 말이다. 며칠 동안 거대한 난장판을 만들다가 한참 후에야 치우는 것이 아니다. 1분 혹은 2분 동안 조금 헝클어뜨리고는, 바로 치우는 것이다.   

리팩터링이라는 단어가 일정에 나타나서는 안 된다. 리팩터링은 계획을 잡고 하는 활동이 아니다. 리팩터링할 시간을 따로 할당해서도 안 된다. 리팩터링은 소프트웨어를 작성할 때 몇 분마다, 혹은 몇 시간마다 하는 일상적인 작업의 일부일 뿐이다.   

#### 더 큰 리팩터링
가끔은 요구 사항이 바뀌어서 현재의 설계나 구성이 더는 최적이 아니게 될 수 있다. 그래서 시스템 구조를 꽈 많이 바꿔야 할 수도 있다. 이런 변경도 빨강/초록/리팩터링 주기 안에서 일어나야 한다. 이런 설계 변경은 며칠, 몇 주, 아니면 몇 달이 걸릴 수도 있다. 이 과정내내 시스템의 테스트는 계속해서 통과해야 한다. 서비스 배포도 계속해서 가능해야 한다. 설계 변경으로 인한 이관 작업이 완전히 끝나지 않는 상황이더라도 말이다.   

## 🍭  클린 코드

### P.154 단위 테스트

#### TDD 법칙 세 가지
- 첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

위 세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다. 테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.   
이렇게 일하면 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나온다. 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

#### 깨끗한 테스트 코드 유지하기
지저분한 테스트 코드를 내놓으나 테스트를 안 하나, 아니 오히려 더 못하다. 문제는 실제 코드가 진화하면 테스트 코드도 변해야 한다. 그런데 테스트 코드가 지저분할수록 변경이 어려워진다. 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 십상이다. 실제 코드를 변경해 기존 테스트 케이스가 실패하기 시작하면, 지저분한 코드로 인해, 실패하는 테스트 케이스를 점점 더 통과시키기 어려워진다. 그래서 테스트 코드는 계속해서 늘어나는 부담이 되버린다. 그렇므로 **테스트 코드는 실제 코드 못지 않게 중요하다.** 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다.   

테스트는 유연성, 유지보수성, 재사용성을 제공한다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 **단위 테스트**다. 이유는 테스트 케이스가 있으면 변경이 두렵지 않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까 두렵기 때문이다.   

하지만 테스트 케이삭 **있다면** 공포는 사실상 사라진다. 테스트 커버리지가 높을수록 공포가 줄어든다. 아키텍처가 부실한 코드나 설계가 모호하고 엉망인 코드라도 별다른 우려 없이 변경할 수 있다.   

그러므로 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트 케이스가 있으면 **변경**이 쉬워지기 떄문이다. 따라서 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다.

#### 깨끗한 테스트 코드
깨끗한 테스트 코드를 만들려면? 세 가지가 필요하다. 가독성, 가독성, 가독성.   
어쩌면 가독성은 실제 코드보다 테스트 코드에 더더욱 중요하다. 테스트 코드에서 가독성을 높이려면? 여느 코드와 마찬가지다. 명료성, 단순성, 풍부한 표현력이 필요하다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.

```java
public void testGetPageHierarchyAsXml() throws Exception {
  makePages("PageOne", "PageOne.ChildOne", "PageTwo");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
  );
}

public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {
  WikiPage page = makePage("PageOne");
  makePages("PageOne.ChildOne", "PageTwo");

  addLinkTo(page, "PageTwo", "SymPage");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
  );
  assertResponseDoesNotContain("SymPage");
}

public void testGetDataAsXml() throws Exception {
  makePageWithContent("TestPageOne", "test page");

  submitRequest("TestPageOne", "type:data");

  assertResponseIsXML();
  assertResponseContains("test page", "<Test");
}
```

각 테스트는 명확히 세 부분으로 나눠진다. 첫 부분은 테스트 자료를 만든다. 두 번째 부분은 테스트 자료를 조작하며, 세 번째 부분은 조작한 결과가 올바른지 확인한다.   

위 테스트 코드는 도메인에 특화된 언어(DSL)로 테스트 코드를 구현하는 기법을 보여준다. 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 **언어**다.   

테스트 API코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 **다르다.** 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다. 실제 환경이 아니라 테스트 환경에서 돌아가는 코드이기 때문이다. 실제 환경과 테스트 환경은 요구사항이 판이하게 다르다.

#### 테스트 당 assert 하나
assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 하지만 위 예시 코드에서 "출력이 XML이다"라는 assert 문과 "특정 문자열을 포함한다"는 assert 문을 하나로 병합하는 방식이 불합리해 보인다. 다음 예시 코드에서 보듯이 테스트를 두 개로 쪼개 각자가 assert를 수행하면 된다.

```java
public void testGetPageHierarchyAsXml() throws Exception {
  givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

  whenRequestIsIssued("root", "type:pages");

  thenResponseShouldBeXML();
}

public void testGetPageHierarchyHasRightTags() throws Exception {
  givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

  whenRequestIsIssued("root", "type:pages");

  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
  );
}
```

위에서 함수 이름을 바꿔 given-when-then이라는 관레를 사용했다는 사실에 주목한다. 그러면 테스트 코드를 읽기가 쉬워진다. 불행하게도, 위에서 보듯이, 테스트를 분리하면 중복되는 코드가 많아진다. TEMPLATE METHOD 패턴을 사용하면 중복을 제거할 수 있다. given/when 부분을 부모 크래스에 두고 then 부분을 자식 클래스에 두면 된다. 아니면 완전히 독자적인 테스트 클래스를 만들어 `@Before` 함수에 given/when 부분을 넣고 `@Test` 함수에 then 부분을 넣어도 된다. 하지만 모두가 배보다 배꼽이 더 크다. 이것저것 감안해 보면 결국 이전의 예시 코드처럼 assert 문을 여럿 사용하는 편이 좋다고 생각한다. 단, assert 문 개수는 최대한 줄여야 좋다.   

어쩌면 "테스트 함수마다 한 개념만 테스트하라"는 규칙이 더 낫겠다. 이것저것 잡다한 개념을 연속적으로 테스트하는 긴 함수는 피한다. 즉, assert 문이 여럿이라는 사실이 문제가 아니다. 한 테스트 함수에서 여러 개념을 테스트한다는 사실이 문제다. 그러므로 가장 좋은 규칙은 "개념 당 assert 문 수를 최소로 줄여라"와 "테스트 함수 하나는 개념 하나만 테스트하라"라 하겠다.

#### F.I.R.S.T
꺠끗한 테스트는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 FIRST가 된다.

- **빠르게(Fast)**: 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다는 말이다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다.
- **독립적으로(Independent)**: 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.
- **반복가능하게(Repeatable)**: 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 버스를 타고 집으로 가는 길에 사용하는 (네트워크에 연결되지 않은) 노트북 환경에서도 실행할 수 있어야 한다. 테스특 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.
- **자가검증하는(Self-Validating)**: 테스트는 부울(bool)값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.
- **적시에(Timely)**: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.

> 테스트 코드는 지속적으로 깨끗하게 관리하자. 표현력을 높이고 간결하게 정리하자. 그러면 그만큼 테스트 코드를 짜기가 쉬워진다.   
> 테스트 API를 구현해 도메인 특화 언어(DSL)를 만들자. 그러면 그만큼 테스트 코드를 짜기가 쉬워진다. 테스트 코드를 깨끗하게 유지하자.

## 🍭 실용주의 프로그래머 (Topic 41. 테스트로 코딩하기)

개발자들에게 왜 테스트를 쓰냐고 물어보면 우리가 천공 카드에 코딩하냐고 물어본 것처럼 우리를 처다본다. 그러고는 "우리 코드가 잘 작동하는지 확이하려는 거죠."라고 대답한다. 말끝에 차마 입에 담지 못한 "바보같이"가 들리는 것이다. 하지만 우리는 이 대답이 틀렸다고 생각한다.   

그렇다면 우리가 생각하는 테스트의 중요한 가치는 무엇일까? 여러분은 왜 테스트를 해야 한다고 생각하는가?

> **Tip 66. 테스트는 버그를 찾기 위한 것이 아니다.**

우리는 테스트의 주요한 이득이 테스트를 실행할 때가 아니라 테스트에 대해 생각하고, 테스트를 작성할 때 생긴다고 믿는다.

### 🥕 테스트에 대해 생각하기

일단 함수를 작성했다고 가정해 보자. 이제 테스트를 해야 한다. 어떻게 해야 할까? 일단 테스트 데이터를 사용해야 할 것이다. 아마 여러분이 관리하는 데이터베이스를 연결할 것이다.

```ruby
def return_avid_users(db) do
```

그다음으로는 어떻게 테스트 데이터를 채울지 생각해야 한다. 요구 사항은 "한 주에 동영상을 10개 넘게 보는 사람 목록"이다. 테스트 데이터를 작성하려면 어떤 필드르 쓸지 알아야 한다. 하지만 우리는 요구 사항이 정확하게 무엇을 의미하는지 모르고 사업 부서 담당자는 연락이 안 된다. 필드 이름을 매개 변수로 넘기는 꼼수를 쓰자. 그러면 일단 현재 코드의 테스트가 가능하다. 필요하면 나중에 바꾸면 될 것이다.   

```ruby
def return_avid_users(db, qualifying_fields_name) do
```

테스트에 대해 생각하는 것으로 시작했는데 코드 한 줄 쓰지 않고도 두 가지를 발견했다. 그리고 이를 바탕으로 우리 메서드의 API를 변경했다.

### 🥕 테스트가 코딩을 주도한다
이전 예에서 테스트에 대해 생각함으로써 우리 코드의 결합도는 낮추고 유연성은 올릴 수 있었다. 우리 메서드의 테스트 작성에 대해 생각함으로써 코드의 작성자가 아니라 사용자인 것처럼 메서드를 외부의 시선으로 보게 되었다.

> **Tip 67. 테스트가 코드의 첫 번째 사용자다.**

이것이 테스트가 주는 가장 큰 이득일지 모른다. 테스트는 우리의 코딩을 인도하는 필수 피드백이다.   
다른 코드와 긴밀하게 결합된 함수나 메서드는 테스트하기 힘들다. 메서드를 실행하기도 전에 온갖 환경 구성을 한참 해야 하기 때문이다. 즉, 무언가를 테스트하기 좋게 만들면 결합도도 낮아진다.   

게다가 무언가를 테스트하려면 그것을 이해해야만 한다. 코딩을 시작하기 전에 경계 조건의 테스트와 경계 조건에서 어떻게 동작해야 하는지를 먼저 생각해본다면, 아마 함수를 단순하게 만드는 코드 패턴을 찾을 수 있을 것이다. 테스트해야 하는 오류 조건에 대해 생각해 본다면 그에 맞게 함수 구조를 잡을 것이다.   

#### 테스트 주도 개발
테스트를 먼저 생각하는 것의 이점이 이렇게 많다 보니 아예 테스트를 먼저 작성하자고 주장하는 프로그래밍 유파도 있다. 그들은 "테스트 주도 개발(TDD)"이라고 부르는 기법을 사용한다. 테스트 우선 개발이라고 부르기도 한다.   

TDD의 기본 주기는 다음과 같다.

1. 추가하고 싶은 작은 기능 하나를 결정한다.
2. 그 기능을 구현되었을 때 통과하게 될 테스트를 하나 작성한다.
3. 테스트를 실행한다. 다른 테스트는 통과하고 방금 추가한 테스트 딱 하나만 실패햐아 한다.
4. 실패하는 테스트를 통과시킬 수 있는 최소한의 코드만 작성한다. 그리고 이제 모든 테스트가 통과하는지 확인한다.
5. 코드를 리팩터링한다. 방금 작성한 테스트나 함수를 개선할 수 있는 부분이 없는지 살펴본다. 개선한 후에도 테스트가 계속 통과하는지 확인한다.

TDD 발상의 핵심은 이 반복 주기가 기껏해야 몇 분 정도로 매우 짧아야 한다는 것이다. 따라서 끊임없이 테스트 작성과 테스트를 통과하게 만들기를 반복하게 된다. TDD 작업 방식을 따르면 여러분의 코드는 언제나 테스트가 있을 수밖에 없다. 그리고 이는 언제나 테스트에 대해 생각하게 된다는 의미다.   
하지만 우리는 TDD의 노예가 된 사람들도 보았다. 다음과 같은 징후로 알아볼 수 있다.

- 늘 테스트 커버리지 100%를 달성하기 위해 과도하게 많은 시간을 투자한다.
- 많은 수의 중복 테스트가 생긴다. 예를 들어 많은 TDD 지지자들은 크래스를 처음으로 작성하기 전에 단순히 클래스 이름만 참조해서 실패하는 테스트를 만든다. 테스트가 실패하고 나면 그제야 빈 클래스 정의를 작성하고, 테스트가 통과하게 된다. 하지만 이제 그 테스트는 아무 일도 하지 않는 테스탁 되고 만다. 다음으로 작성하는 테스트도 당연히 클래스를 참조할 것이므로 첫 번째 테스트는 불필요해진다. 나중에 클래스 이름을 바꿔야 하는 곳만 많아질 뿐이다. 그리고 이건 중복 테스트의 사소한 예일 뿐이다.
- 밑에서부터 시작하여 위로 올라가는 방식으로 설계를 한다.

어떻게든 TDD를 실천하라. 하지만 도중에 이따금 멈추어 큰 그리을 살피는 것을 잊지 말라. 초록색 "테스트 통과" 메시지에 중독된 나머지 진짜 문제 해결에는 보탬이 안되는 코드를 한 무더기나 쓰게 되기 쉽다.

### 🥕 TDD: 목표가 어디인지 알아야 한다
전체 문제를 완전히 파악하기 힘들 때 한 번에 테스트 하나씩 작은 단계들을 밟는 것이다. 하지만 이런 접근 방법이 여러분을 잘못된 길로 인도할 수 있다. 코딩을 하는 진짜 이유는 무시한 채 계속해서 쉬운 문제들만 만지작거리도록 유도할 수 있다.

> **상향식 대 하향식, 그리고 여러분이 따라야 하는 방식**   
> 상향식 하향식 둘 다 소프트웨어 개발의 가장 중요한 측면을 놓치고 있다. 바로 개발을 처음 시작할 때는 우리가 무엇을 하고 있는지 모른다는 것이다. 하향식 설계는 전체 요구사항을 시작할 때 다 알고 있다고 가정하지만 사실은 알 수 없다. 상향식 설계는 추상화 계층을 쌓다 보면 결국에는 하나의 최상위 해결 계층에 도착할 것이라고 가정하지만, 목표가 어디인지 모르는데 어떻게 각 계층의 기능을 결정할 수 있단 말인가?   
> **Tip 68. 상향식이나 하향식이 아니라 끝에서 끝까지(end to-end) 만들어라.**   
> 우리는 소프트웨어를 만드는 유일한 방법이 점진적인 방법이라고 굳게 믿는다. 한쪽 끝과 다른 쪽 끝을 잇는 조그만 기능 조각들을 만들고, 그 과정에서 문제에 대하여 배워라. 코드를 채워 나가면서 배운 것을 적용하고, 각 단계마다 고객을 참여시켜서 전체 과정을 안내하도록 하라.

### 🥕 다시 코드로
소프트웨어를 만들 때 맨 처음부터 테스트가 가능하도록 만들고, 코드들을 서로 연결하기 전에 코드를 하나하나 철저하게 테스트해야만 한다.

### 🥕 단위 테스트
소프트웨어 단위 테스트란 일종의 인위적인 환경을 구축한 다음, 테스트할 모듈의 루틴들을 호출한다. 그런 다음 반환된 결과들을 이미 알고 있는 값과 비교해 보거나 똑같은 테스트를 이전에 돌렸을 때 나온 값과 비교하여 올바른지 검사한다. 동일한 테스트를 코드 수정 후 다시 돌려보는 것을 회귀 테스트라고 한다.   

### 🥕 계약을 지키는지 테스트하기
우리는 단위 테스트를 계약을 잘 지키는지 보는 테스트라고 여긴다. 우리는 어떤 코드 단위가 자신이 맺은 계약을 지키는지 확인하는 테스트 케이스를 작성하고자 한다. 이런 테스트는 우리에게 두 가지를 알려준다. 하나는 코드가 계약을 지키는지 여부고, 다른 하나는 코드로 표현된 계약의 의미가 우리가 생각한 것과 일치하는지 여부다. 우리는 다양한 종류의 테스트 케이스와 경계 조건에서도 모듈이 약속한 대로 기능을 잘 수행하는지 테스트하고 싶다.   

어떤 모듈이 있을 떄 그 모듈의 하위 컴포넌트들을 먼저 테스트하는 방식이다. 하위 컴포넌트들을 모두 검증한 후에야 해당 모듈을 테스트할 수 있다. 만약 `DataFeed`와 `LinearRegression`은 테스트를 통과하는데 테스트를 통과하지 못했다면, 문제가 있거나 아님 하위 컴포넌트를 사용하는 방식에 있다고 거의 확신할 수 있따. 이 기법은 디버깅에 들어가는 노력을 줄여 주는 멋진 방법이다.   

왜 이렇게 번잡한 일을 하는 것일까? 무엇보다도 "시한폭탄", 즉 문제가 프로젝트에서 알려지지 않은 채로 숨어 있다가 나중에 곤란한 시점에 터져 버리는 일을 피하고 싶어서다. 계약을 잘 지키는지 확인하는 테스트를 강조함으로써 프로젝트에서 이후에 벌어질지 모를 재앙을 피하려고 노력하는 것이다.   

> **Tip 69. 테스트할 수 있도록 설계하라.**

### 🥕 임시 테스트
임시(Ad-hoc) 테스트는 우리가 직접 코드를 이리저리 찔러보는 것이다. `console.log()` 한 줄일 수도 있고, 디버거나 IDE 환경, REPL에 직접 실행하면서 입력하느 코드 조각일 수도 있다.   

디버깅 작업이 끝나면 이런 임시 테스트를 정식 테스트의 형태로 만들어두어야 한다. 한 번 잘못된 코드라면 다시 잘못될 가능성이 높다. 여러분이 만든 테스트를 그냥 버리지 말고 기존의 단위 테스트 군단에 합류시켜라.

### 🥕 테스트 접점 만들기
아무리 테스트를 잘 갖추었어도 모든 버그를 발견할 수는 없다.   

이 말은 소프트웨어를 배포한 후에도 테스트할 일이 자주 생긴다는 것이다. 이때 소프트웨어를 배포한 후에도 테스트할 일이 자주 생긴다는 것이다. 어떤 모듈의 내부 상태를 디버거 없이 다양한 형태로 볼 수 있는 방법을 제공할 수도 있다.   
로그 파일에 쌓이는 추적 메시지가 이런 메커니즘 가운데 하나다. 로그 메시지는 반드시 규칙적이고 일관된 형식이어야 한다.   

실행 중인 코드의 내부로 들어갈 수 있는 또 다른 메커니증므로 단축키 조핳ㅂ이나 숨겨진 URL 방식이 있다. 어떤 특정한 키 조합을 누르거나 특정 URL에 접속하면, 상태 정보와 그 외의 것들이 들어 있는 진단 제어 창이 열리게 만드는 것이다.   

더 일반적으로는 기능 스위치를 활용하여 특정 사용자나 사용자 집단에 대해서는 진단 메시지를 더 많이 남기도록 할 수도 있다.

### 🥕 테스트 문화
여러분이 작성하는 모든 소프트웨어는 **언젠가는** 테스트된다. 여러분이나 여러분의 팀이 테스트하지 않으면 결과적으로 사용자들이 테스트하게 된다. 그러니 소프트웨어를 철저하게 테스트할 계획을 세우는 것이 좋다.   

여러분에게 있는 선택지는 그리 많지 않다. "테스트 먼저", "코드와 테스트를 함께", "테스트하지 않음" 셋 중 하나다.   

"테스트 먼저"가 대부분의 상황에서 최상의 선택일 것이다. 테스트를 할 수 밖에 없기 때문이다. 테스트 주도 설계도 여기에 포함된다. 하지만 때에 따라 테스트를 먼저 쓰기가 어렵거나 의미가 없을 수도 있다. 그렇다면 "코드와 테스트를 함꼐"가 대안이 될 수 있다. 코드를 조금 작성하고, 이리저리 만지작저리다가 테스트를 작성하라. 그리고 다시 코드로 넘어간다. 최악의 선택은 흔히들 "나중에 테스트"라고 부르는 것인데, 완전 헛소리다. "나중에 테스트"는 사실 "테스트하지 않음"이란 뜻이다.   

제대로 된 테스트 문화를 가졌다면 모든 테스트가 언제나 통과해야 한다.   
"언제나 실패"하는 불량 테스트를 무시하다 보면 모든 테스트를 무시하게 되기 쉽다. 그리고 악순환의 고리가 시작된다.   

테스트 코드를 다른 제품 코드와 마찬가지로 다뤄라. 결합도를 낮추고, 꺠끗하고 견고하게 유지하라. GUI 시스템의 위젯 위치나 서버 로그에 찍힌 현재 시간, 에러 메시지의 문구처럼 신뢰할 수 없는 것에 의존하지 말라. 이런 종류의 것을 테스트하면 테스트가 더 잘 깨지게 된다.

> **Tip 70. 여러분의 소프트웨어를 테스트하라. 그렇지 않으면 사용자가 테스트하게 된다.**

명심하라. 테스트는 프로그래밍의 일부다. 다른 사람이나 다른 부서에 떠넘길 수 있는 것이 아니다.   
테스트, 설계, 코딩, 이 모든 것이 프로그래밍이다.

> **고백**   
> 나 데이브는 사람들에게 더는 테스트를 쓰지 않는다고 말해 왔다. 테스트를 종교처럼 떠받드는 사람들의 믿음을 흔들기 위한 것도 있고, 또 어느 정도는 테스트를 쓰지 않는 것이 사실이기 때문이기도 하다.   
> 나는 45년간 코딩을 해 왔고, 30년 넘게 늘 자동화 테스트를 써 왔다. 코딩을 시작할 때면 자연스럽게 테스트에 대해 생각한다. 아주 편안하게 느껴진다. 그리고 나느 ㄴ무언가가 편안하게 느껴지면 또 다른 시도를 해 봐야 하는 천성을 타고났다.   
> 그래서 나는 몇 달 전 테스트 쓰기를 그만두고 내 코드에 무슨 일이 벌어지는지 한번 보기로 했다. 놀랍게도 변화는 "크지 않았다." 그래서 왜 그런지 곰곰이 생각해 보았다.   
> **내 생각에 나에게 있어 테스트의 이득은 대부분 테스트에 대하여, 그리고 테스트가 코드에 주는 영향에 대하여 고민하는 과정에서 생기는 듯 하다.** 그리고 꽤 오래 이 일을 해 오다보니 실제로 테스트를 쓰지 않고도 테스트에 대해 생각할 수 있게 되었다. 내 코드는 여전히 테스트하기 쉽다. 아직 테스트하지 않았을 뿐이다.   
> 하지만 이런 관점은 **테스트가 다른 개발자와 소통하는 수단이기도 하다는 측면을 무시한 것이다.** 그래서 이제는 다른 사람들과 공유하는 코드 혹은 외부 라이브러리의 어떤 특성에 의존하는 코드만 테스트를 작성한다.   
> 앤디는 이 상자의 내용을 싣지 말자고 했다. 경험이 부족한 개발자들이 괜히 따라서 테스트를 쓰지 않을까 봐 걱정이라는 것이다. 그래서 나의 타협안은 다음과 같다.   
> **여러분이 테스트를 써야 할까? 그렇다.** 하지만 테스트 작성 경험이 30년 정도 쌓였다면 테스트가 어떤 면에서 도움이 되는지 직접 실험을 해 봐도 좋을 것이다.
