# 🍬 Test와 TDD에 대한 정리

## 🍭 함께 자라기

### P.73
테스트 주도 개발(TDD)을 잘하려면 앞에서 말한 동적인 균형 맞추기를 잘해야 한다. 이걸 잘하면 지속적으로 몰입을 경험할 수 있고 실력이 일신우일신할 수 있다.

#### 지루함을 느끼는 경우: 실력 낮추기
작업의 난이도는 그대로 두고 실력을 낮추는 전략이다. 프로그래머의 예로 들자면, 평상시 즐겨 쓰던 보조 도구를 일부러 안 쓰는 것이다. 디버거를 늘 쓰는 경우 디버거를 안 쓰는 것이다.   

이렇게 난이도와 실력이 잘 맞아 들어가기만 하면 의도적 수련이 될 수 있다.

#### 지루함을 느끼는 경우: 난이도 높이기
실력은 그대로 두고 난이도를 높이는 전략이다. 흔하게 쓰는 방법은 자기에게 요구되는 수준을 더 높게 여기는 것이다. 하루 만에 개발하라고 주어진 업무인데 지루한 느낌이 드니 한 시간 만에 할 수 있는 방법을 고안해 보기, 평소 코드를 검토할 때 버그를 시간당 하나 찾았다면 오늘은 두 개 찾기, 익숙한 작업을 새로운 언어로 진행해 보기 등.   
보통 자신의 업무를 개선하는 일로 리팩터링을 하거나 자동화 테스트를 달거나, 혹은 자신만의 도구를 개발하거나 하는 것들도 있다.   

#### 불안함을 느끼는 경우: 실력 높이기
실력을 높여 몰입 영역으로 들어가는 방법이다. 장기적으로 실력을 높이는 방법은 책을 보거나 스터디에 참가하거나 교육을 듣거나 등등. 하지만 지금 당장 불안함을 느끼고 있다면 어떻게 해야 하는가가 문제이다. 크게 보면 사회적 접근과 도구적 접근, 내관적 접근 세 가지가 가능하다.   

사회적 접근은, 나보다 뛰어난 전문가의 도움을 얻는 것이다. 잘하는 사람한테 가서 짝 프로그래밍을 해달라고 부탁하거나 IRC(인터넷 체팅)에서 전문가의 도움을 얻는 것도 괜찮은 방법이다.   

도구적 접근은 다른 도구의 도움을 받는 것이다. 내 능력을 확장시켜 줄 수 있는 도구들을 찾아 쓰면 된다.   

내관적 접근은 비슷한 일을 했던 경험을 머릿속에서 되살려 보는 것이다. 그때 그 일을 어떻게 했는지 떠올려 보면서 비유적으로 문제를 해결한다. 보통 이런 과정을 거치면 자기효용감이 증대하면서 스스로 인식하는 자기 실력이 향상되기 쉽고, 결과적으로 몰입 영역으로 들어가기 좋다.   

#### 불안함을 느끼는 경우: 난이도 낮추기
불안함을 느낄 때 난이도를 낮춰서 몰입 영역으로 들어가는 전략이다.   

간단하면서 효과적인 방법은 자신이 맡은 일의 가장 간단하면서 핵심적인 결과물, 즉 아기 버전(혹은 0.0.1 버전)을 첫 번째 목표로 삼는 것이다. 애자일에서 말하는 WTSTTCPW(What's The Simplest Thing That Could Possibly Work?, 동작할 수도 있는 가장 간단한 건 뭘까?)와 같다.

### P.98
TDD 교육을 통해 사람들이 기대하는 과정은 보통 이럴 것이다.   

1. TDD를 제대로 이해하고 조직에 돌아간다.
2. 나 스스로 TDD를 제대로 실천해서 객관적 성과를 낸다.
3. TDD가 좋다고 사람들을 설득한다.
4. TDD를 가르쳐 준다.
5. 모두가 TDD를 열심히 한다.
6. 좋은 성과를 낸다.

여기에서 보통 문제가 되는 부분은 3, 4, 5, 6번이다. 그리고 1과 2를 잘한다고 해서 3번 이후가 꼭 쉬어지는 것이 아니다. 하지만 교욱에서는 통상 1번에만 집중을 한다. 이럴 경우, 실무로 돌아갔을 때 흔히 접하는 문제는 예컨대 다음과 같다.   

- 회사로 돌아가서 실무에 적용하려고 하는데 상사나 동료의 지원 없이 추가적으로 일을 하려니, 시간이 모자라 계속 미루게 되어 결국 적용하지 못한다.
- 팀원, 팀장들에게 전파 교육을 하려 하지만 팀원, 팀장들 가운데 몇몇은 추가 업무를 왜 하는지 필요성도 못 느끼는 상태에서 강제로 해야 한다는 스트레스를 받아서 부작용이 생긴다(그래서 결과적으로 해당 기법은 실무에 써먹을 수 없다는 평가가 나온다).
- 배운 것을 팀 내에서는 열심히 적용했으니 지원해주는 임원이 없어 확대하는 데 실패하고, 조직 내에서는 한 팀의 별난 문화로 치부되어 실행 범위가 축소된다.
- 배운 대로 팀에서 실천했더니 "다른 부서는 그런 거 없이도 잘하는데 너희는 왜 그런 거 하면서 제때 아웃풋이 안 나오냐"며 이해할 수 없다고 말하는 상사나 협력 팀의 리더와 갈등을 겪는다.
- 기술적으로 어떻게 해야 할지 모르겠는데, 주변에 물어볼 사람이 없어 인터넷 검색하느라 몇 시간씩 보낸다. 하지만 결국 원하는 정보를 찾지 못해서 적용을 포기한다.
- 회사에서는 여력이 없어 배운 것을 집에서 시도해 보려 했더니, 가족들의 여러 요구로 인해 집중할 수 없어 화를 내거나, 가족의 요구대로 하느라 내가 할 일은 시작도 못하거나, 그냥 포기하고 잠을 자게 된다.

이런 문제들은 보통 **사회적 측면**에 대한 것이다. 뭘 하던지 나 혼자가 아니라 항상 누군가가 등장하고, 일의 성패에 다른 사람이 관련되어 있기 때문이다.   

아무리 기술적인 실천법이라고 해도 그 기술은 사회적 맥락 속에서 실천되어야 하며 그 기술의 성공을 위해서는 **사회적 자본**과 **사회적 기술**이 함께 필요하다.   

하지만 안타깝게도 현실에서는 **팀원들이 맘에 안 들고, 그들도 나를 맘에 들어 하지 않는 상황, 즉 사화적 맥락이 나쁜 상황에서 타개책으로 TDD의 기술적 측면에만 매몰되는 경우**가 있다. 사실 그런 상황에서는 무엇을 골라도 실패가 보장되어 있다.

다시 한번 반복한다.**어떤 기술적 실천법이라도 그걸 현실에서 적용하기 위해서는 사회적 자본과 기술이 필요**하다. 설사 나 혼자 하는 실천법이라도 해도 말이다.   

TDD 도입에 실패하는 경우, 무엇이 병목이었나를 살펴보면 사람들이 TDD의 기술적 내용을 잘 몰라서보다도 TDD를 도입하는 데에 필요한 **사회적 자본**과 **사회적 기술**이 없어서가 훨씬 더 많았다. 그렇기 때문에 어떤 기술적 지식을 전달한다고 해도 그것을 사회적 맥락 속에서 가르치고 경험하게 해야 한다. 사회적 기술에는 도움받기, 피드백 주고받기, 영향력 미치기, 가르치고 배우기, 위임하기 등이 있다.   

## 🍭  클린 애자일

### P.130 테스트 주도 개발
많은 프로그래머가 애자일을 시도할 때 기술 실천 방법은 빼놓는다. 기술 실천 방법이야말로 애자일의 진짜 핵심이기 떄문이다. TDD와 리팩터링, 단순한 설계, 심지어 짝 프로그래밍도 없다면, 애자일은 원래 의도와는 달리 쓸모없는 빈 껍데기가 되고 만다.   

테스트 주도 개발은 프로그래머의 복식 부기라고 할 수 있다. 구현해야하는 동작을 두 번씩 입력한다. 한 번은 테스트로, 그리고 한 번은 이 테스트를 통과하게 만드는 제품 코드로 말이다. 두 번의 입력은 서로 딱 맞아야 한다.   

TDD를 공부할 떄, 기능을 한 번에 하나씩만 추가한다. 실패하는 테스트 형태로 먼저 하나 추가하고, 이 테스트를 통과하게 만드는 제품 코드 형태로 다시 추가한다. 이렇게 하면 오류를 빠르게 찾을 수 있다.

#### TDD의 세 가지 규칙
1. 해당 코드가 없어서 실패하는 테스트 코드를 쓰기 전에 제품 코드를 먼저 쓰면 안 된다.
2. 테스트 코드를 쓸 때는 실패하도록 만들기 위해 필요한 것보다 더 많이 쓰면 안 된다. 컴파일 실패도 실패로 간주한다.
3. 실패하는 테스트를 통과시키기 위해 필요한 코드보다 더 많은 제품 코드를 쓰면 안 된다.

이 세 가지 규칙을 잘 지킨다면 특정 순간에 한 명을 고른다. 이 프로그래머가 작업하던 코드는 아무리 길어도 1분 전까지는 실행 가능했고, 테스트를 모두 통과했다. 누구를 고르더라도, 어느 시점에 고르더라도 상관없다. 아무리 길어도 1분 전까지는 모든 것이 작동했다. 그렇기 떄문에 쉽게 원인을 알아낼 수 있다.   

디 버깅에 많은 시간을 쓴다는 것은 언제나 그만큼 버그가 많다는 것이다. 테스트 주도 개발을 하면 디버거를 쓸 일이 별로 없기 때문에 디버거에 익수해질 수가 없다.

#### 문서화
이 세 가지 규칙을 따르다보면 만들어지는 테스트는 전체 시스템의 코드 예제가 된다. API 함수를 어떻게 부르는지 알고 싶다면 테스트를 보면 된다. 테스트는 이 함수를 호출하는 모든 방법을 보여 주고, 이 함수가 던지는 모든 예외를 처리하는 방법을 보여 줄 것이다.   

테스트는 테스트하는 시스템을 설명하는 문서의 한 형태다. 이 문서는 프로그래머가 능숙하게 구사하는 언어로 쓰여 있다. 전혀 모호하지 않고, 규칙이 정해져 있어서 실행할 수 있을 정도다. 프로그래머에게 완벽한 형식의 문서가 있다면, 코드 형태일 것이다. 테스트가 바로 그렇다.   

더 좋은 것은 테스트 자체만으로는 시스템을 만들지 못한다는 것이다. 테스트끼리는 서로 묶여 있지 않다. 테스트 간에는 의존성도 없다. 각 테스트는 시스템 중 작은 부분의 동작을 설명하는 작고 독립적인 코드 조각일 뿐이다.

#### 재미
제품을 다 만든 이후에 테스트를 작성해 본 적이 있다면, 재미없는 일이라는 것을 알 것이다. 잘 작동하는 것을 알고 있으니 재미가 없다.   

세 가지 규칙을 따라서 테스트를 먼저 작성하면 재미있다. 테스트 하나가 모두 도전이다. 테스트를 통과하게 만들 때마다 작은 성공을 거두는 것이다. 세 가지 규칙을 따른다면 작업 과정은 작은 도전과 성공의 연속이 된다.   

#### 완벽함
사후 테스트 추가는 이미 손으로 테스트해 봐서 잘 작동한다는 것을 알고 있지만, 의무감에 테스트를 쓰고 있을 것이다. 테스트를 추가할 때마다 테스트가 통과하는 것은 당연한 일이다.   

그러다 보면 테스트를 만들기 힘든 경우를 만나게 될 것이다. 테스트를 만들기 힘든 이유는 테스트 가능 여부를 생각하지 않으면서 코드를 작성하고, 설계할 때도 테스트를 고려하지 않았기 때문이다. 이 코드의 테스트를 만들려면 결합된 곳을 몇 군데 깨고, 추상화를 몇 군데 하고, 함수 호출과 인자 몇 개를 이리저리 옮겨야 할 거 같다. 결국 코드의 구조을 뜯어고쳐야 한다. 이미 코드가 잘 작동하는데 굳이 고치려하니 왠지 일이 더 커 보인다.   

일정은 빡빡하고, 더 급한 일이 많이 기다리고 있다. 일단 테스트는 저리 치워놓자. 테스트는 굳이 필요하지 않다거나, 나중에 돌아와서 다시 작성하면 된다고 자기 합리화를 한다. 이렇게 테스트에 구멍을 남겨놓게 되는 것이다.    

테스트가 통과한다고 해서, 이것을 근거로 내릴 수 있는 결정은 없다. 테스트 통과로 얻은 정보는 테스트가 깨지지 않았다는 것뿐이다. 불완전한 테스트 묶음으로는 아무런 결정은 할 수 없다. 하지만 세 가지 규칙을 잘 따랐다면, 모든 제품 코드는 테스트를 통과하게 만들려고 쓴 것이다. 따라서 테스트 묶음이 아주 완벽할 것이다. 테스트가 통과했다면 결정을 내릴 수 있다. 그 결정은 바로 "배포"다.   

세 가지 규칙을 따르면 아주 와벽한 테스트 묶음이 생길 것이다. 하지만 아마 100% 완벽하지는 않을 것이다. 사실 세 가지 규칙을 따르는 것이 현실적이지 않은 상황이 있기 때문이다. 아무리 성실하게 세 가지 규칙을 따르더라도 100% 완벽한 테스트 묶음이 만들어지지는 않는다. 하지만, 배포를 위해 꼭 100%의 완벽함이 필요한 것은 아니다. 커버리지가 90%대 후반 정도면 충분할 것이다. 그리고 이 정도는 당연히 달성할 수 있다.

> 나는 배포 결정을 내릴 수 있을 만큼 완벽한 테스트 묶음을 만들어 왔고, 다른 사람들이 하는 것도 봐 왔다. 이런 사례에서도 커버리지는 100%가 되지 않았다. 하지만 배포 결정을 내리기 충분했다.
> - 테스트 커버리지는 팀 내부용 지표이지 관리 지표가 아니다. 관리자는 아마 이 숫자가 어떤 의미인지 제대로 알지도 못할 것이다. 관리자는 테스트 커버리지를 목표나 목적으로 삼아서는 안 된다. 테스트 커버리지는 팀의 테스트 전략을 확인하기 위해서만 사용해야 한다.
> - 커버리지가 낮다고 빌드에 실패한 것으로 보아서는 안 된다. 이렇게 하면, 프로그래머는 커버리지를 높이기 위해 단언문도 없이 테스트를 넣어 버릴 것이다. 코드 커버리지는 코드와 테스트에 대한 깊은 지식이 있어야 이해할 수 있는 복잡한 주제다. 절대 관리용 지표로 삼아서는 안 된다.

#### 설계
테스트를 먼저 쓰면 테스트하기 힘든 함수는 쓸 수가 없다. 테스트를 먼저 쓰기 때문에 테스트하기 쉬운 설계가 나오는 것은 당연하다. 어떻게 함수를 테스트하기 쉽게 유지할 수 있을까? 결합을 끊고 분리하면 된다. 사실 테스트할 수 있다는 것은 분리했다는 것과 같은 뜻이다.   

전체 시스템에 모두 테스트가 있을 것이므로, 전체 시스템이 잘 분리되어 있을 것이다. 이 세 가지 규칙이 훨씬 더 잘 분리된 설계를 하도록 만든다.

#### 용기
TDD를 하는 진정한 이유는 용기이다.    

리팩토링시 코드를 두려워하게 된다. 코드를 건드리는 것을 두려워하고, 코드가 망가뜨릴 때 당신에게 벌어질 일을 두려워한다. 그래서 코드를 정리하는 데 실패한다. 코드를 개선하는 데 실패한다. 이리저리 결합이 생기고, 중복인 코드가 계속 추가될 것이다. 그렇기 때문에 작업에 걸리는 시간은 기하급수적으로 증가할 것이다.   

결국 관리자는 좌절할 것이고 시스템 밑바닥에서부터 다시 만들자는 프로그래머들의 요구를 수용하고 만다. 그리고 역사는 반복될 것이다.   

완벽한 테스트 묶음이 있으면 코드를 고치는 두려움이 사라진다. 코드를 정리하는 두려움이 사라진다. 따라서 코드를 정리할 것이다. TDD는 용기를 준다. 용기가 있어야 코드를 깨끗하고 정돈된 상태로 관리할 수 있다.

### P.140 리팩터링
리팩터링은 코드의 구조를 개선하면서 동작은 바꾸지 않는 실천 방법이다. 프로그램의 동작은 테스트로 정의해야 한다. 다시 말해서, 테스트를 꺠먹지 않으면서 이름이나 클래스, 함수, 표현식을 변경하는 것이다. 동작에 영향을 주지 않으면서 시스템 구조를 개선한다.   

당연히 리팩터링은 TDD와 밀접한 관련이 있다. 두려움 없이 코드를 리팩터링하려면, 무언가 꺠 먹지 않았다는 확신을 얻을 수 있는 테스트 묶음이 필요하다.   

리팩터링 과정에서 하는 일은 사소하게는 코드를 조금 더 보기 좋게 만드는 것부터 근본적인 구조 변경까지 다양하다. 이 모든 일이 일어나는 동안, 테스트는 계속해서 통과해야 한다.

#### 빨강/초록/리팩터링
본질적으로 리팩터링은 TDD의 세 가지 규칙을 반복함으로써 이루어진다.   
리팩터링에서는 빨강/초록/리팩터링 주기라고 부른다.   

1. 먼저, 실패하는 테스트를 만든다.
2. 그리고 이 테스트를 통과하게 만든다.
3. 그리고 코드를 정리한다.
4. 1단계로 돌아간다.

여기서 핵심은 프로그래밍이라는 과업을 작동하는 코드를 쓰는 것과 정리하기라는 두 가지 다른 측면으로 분리한 것이다. 두 가지 측면을 동시에 다루는 것은 어려울 수밖에 없다. 그러므로 두 가지 측면을 두 가지 다른 활동으로 분리한다.   

쉽게 말하면, 깨끗한 코드를 만드는 것을 고사하고, 그저 테스트를 통과하게 만드는 것만으로도 충분히 어렵다. 그러니 먼저 코드가 작동하게 만드는 데만 집중하자. 일단 머리에 떠오르는 어떤 지저분한 수단이든 동원해서 말이다. 그리고 일단 작동하면, 테스트는 통과했을 것이고, 이제 그동안 만든 지저분한 것들을 정리하자.   

이렇게 보면 리팩터링이 연속적인 과정이라는 것이 명확해진다. 따로 일정을 잡고 하는 작업이 아니라는 말이다. 며칠 동안 거대한 난장판을 만들다가 한참 후에야 치우는 것이 아니다. 1분 혹은 2분 동안 조금 헝클어뜨리고는, 바로 치우는 것이다.   

리팩터링이라는 단어가 일정에 나타나서는 안 된다. 리팩터링은 계획을 잡고 하는 활동이 아니다. 리팩터링할 시간을 따로 할당해서도 안 된다. 리팩터링은 소프트웨어를 작성할 때 몇 분마다, 혹은 몇 시간마다 하는 일상적인 작업의 일부일 뿐이다.   

#### 더 큰 리팩터링
가끔은 요구 사항이 바뀌어서 현재의 설계나 구성이 더는 최적이 아니게 될 수 있다. 그래서 시스템 구조를 꽈 많이 바꿔야 할 수도 있다. 이런 변경도 빨강/초록/리팩터링 주기 안에서 일어나야 한다. 이런 설계 변경은 며칠, 몇 주, 아니면 몇 달이 걸릴 수도 있다. 이 과정내내 시스템의 테스트는 계속해서 통과해야 한다. 서비스 배포도 계속해서 가능해야 한다. 설계 변경으로 인한 이관 작업이 완전히 끝나지 않는 상황이더라도 말이다.   

## 🍭  클린 코드

### P.154 단위 테스트

#### TDD 법칙 세 가지
- 첫째 법칙: 실패하는 단위 테스트를 작성할 때까지 실제 코드를 작성하지 않는다.
- 둘째 법칙: 컴파일은 실패하지 않으면서 실행이 실패하는 정도로만 단위 테스트를 작성한다.
- 셋째 법칙: 현재 실패하는 테스트를 통과할 정도로만 실제 코드를 작성한다.

위 세 가지 규칙을 따르면 개발과 테스트가 대략 30초 주기로 묶인다. 테스트 코드와 실제 코드가 함께 나올뿐더러 테스트 코드가 실제 코드보다 불과 몇 초 전에 나온다.   
이렇게 일하면 실제 코드를 사실상 전부 테스트하는 테스트 케이스가 나온다. 하지만 실제 코드와 맞먹을 정도로 방대한 테스트 코드는 심각한 관리 문제를 유발하기도 한다.

#### 깨끗한 테스트 코드 유지하기
지저분한 테스트 코드를 내놓으나 테스트를 안 하나, 아니 오히려 더 못하다. 문제는 실제 코드가 진화하면 테스트 코드도 변해야 한다. 그런데 테스트 코드가 지저분할수록 변경이 어려워진다. 테스트 코드가 복잡할수록 실제 코드를 짜는 시간보다 테스트 케이스를 추가하는 시간이 더 걸리기 십상이다. 실제 코드를 변경해 기존 테스트 케이스가 실패하기 시작하면, 지저분한 코드로 인해, 실패하는 테스트 케이스를 점점 더 통과시키기 어려워진다. 그래서 테스트 코드는 계속해서 늘어나는 부담이 되버린다. 그렇므로 **테스트 코드는 실제 코드 못지 않게 중요하다.** 테스트 코드는 사고와 설계와 주의가 필요하다. 실제 코드 못지 않게 깨끗하게 짜야 한다.   

테스트는 유연성, 유지보수성, 재사용성을 제공한다. 코드에 유연성, 유지보수성, 재사용성을 제공하는 버팀목이 바로 **단위 테스트**다. 이유는 테스트 케이스가 있으면 변경이 두렵지 않다. 테스트 케이스가 없다면 모든 변경이 잠정적인 버그다. 아키텍처가 아무리 유연하더라도, 설계를 아무리 잘 나눴더라도, 테스트 케이스가 없으면 개발자는 변경을 주저한다. 버그가 숨어들까 두렵기 때문이다.   

하지만 테스트 케이삭 **있다면** 공포는 사실상 사라진다. 테스트 커버리지가 높을수록 공포가 줄어든다. 아키텍처가 부실한 코드나 설계가 모호하고 엉망인 코드라도 별다른 우려 없이 변경할 수 있다.   

그러므로 실제 코드를 점검하는 자동화된 단위 테스트 슈트는 설계와 아키텍처를 최대한 깨끗하게 보존하는 열쇠다. 테스트는 유연성, 유지보수성, 재사용성을 제공한다. 테스트 케이스가 있으면 **변경**이 쉬워지기 떄문이다. 따라서 테스트 코드가 지저분하면 코드를 변경하는 능력이 떨어지며 코드 구조를 개선하는 능력도 떨어진다.

#### 깨끗한 테스트 코드
깨끗한 테스트 코드를 만들려면? 세 가지가 필요하다. 가독성, 가독성, 가독성.   
어쩌면 가독성은 실제 코드보다 테스트 코드에 더더욱 중요하다. 테스트 코드에서 가독성을 높이려면? 여느 코드와 마찬가지다. 명료성, 단순성, 풍부한 표현력이 필요하다. 테스트 코드는 최소의 표현으로 많은 것을 나타내야 한다.

```java
public void testGetPageHierarchyAsXml() throws Exception {
  makePages("PageOne", "PageOne.ChildOne", "PageTwo");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
  );
}

public void testSymbolicLinksAreNotInXmlPageHierarchy() throws Exception {
  WikiPage page = makePage("PageOne");
  makePages("PageOne.ChildOne", "PageTwo");

  addLinkTo(page, "PageTwo", "SymPage");

  submitRequest("root", "type:pages");

  assertResponseIsXML();
  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
  );
  assertResponseDoesNotContain("SymPage");
}

public void testGetDataAsXml() throws Exception {
  makePageWithContent("TestPageOne", "test page");

  submitRequest("TestPageOne", "type:data");

  assertResponseIsXML();
  assertResponseContains("test page", "<Test");
}
```

각 테스트는 명확히 세 부분으로 나눠진다. 첫 부분은 테스트 자료를 만든다. 두 번째 부분은 테스트 자료를 조작하며, 세 번째 부분은 조작한 결과가 올바른지 확인한다.   

위 테스트 코드는 도메인에 특화된 언어(DSL)로 테스트 코드를 구현하는 기법을 보여준다. 테스트를 구현하는 당사자와 나중에 테스트를 읽어볼 독자를 도와주는 테스트 **언어**다.   

테스트 API코드에 적용하는 표준은 실제 코드에 적용하는 표준과 확실히 **다르다.** 단순하고, 간결하고, 표현력이 풍부해야 하지만, 실제 코드만큼 효율적일 필요는 없다. 실제 환경이 아니라 테스트 환경에서 돌아가는 코드이기 때문이다. 실제 환경과 테스트 환경은 요구사항이 판이하게 다르다.

#### 테스트 당 assert 하나
assert 문이 단 하나인 함수는 결론이 하나라서 코드를 이해하기 쉽고 빠르다. 하지만 위 예시 코드에서 "출력이 XML이다"라는 assert 문과 "특정 문자열을 포함한다"는 assert 문을 하나로 병합하는 방식이 불합리해 보인다. 다음 예시 코드에서 보듯이 테스트를 두 개로 쪼개 각자가 assert를 수행하면 된다.

```java
public void testGetPageHierarchyAsXml() throws Exception {
  givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

  whenRequestIsIssued("root", "type:pages");

  thenResponseShouldBeXML();
}

public void testGetPageHierarchyHasRightTags() throws Exception {
  givenPages("PageOne", "PageOne.ChildOne", "PageTwo");

  whenRequestIsIssued("root", "type:pages");

  assertResponseContains(
    "<name>PageOne</name>", "<name>PageTwo</name>", "<name>ChildOne</name>"
  );
}
```

위에서 함수 이름을 바꿔 given-when-then이라는 관레를 사용했다는 사실에 주목한다. 그러면 테스트 코드를 읽기가 쉬워진다. 불행하게도, 위에서 보듯이, 테스트를 분리하면 중복되는 코드가 많아진다. TEMPLATE METHOD 패턴을 사용하면 중복을 제거할 수 있다. given/when 부분을 부모 크래스에 두고 then 부분을 자식 클래스에 두면 된다. 아니면 완전히 독자적인 테스트 클래스를 만들어 `@Before` 함수에 given/when 부분을 넣고 `@Test` 함수에 then 부분을 넣어도 된다. 하지만 모두가 배보다 배꼽이 더 크다. 이것저것 감안해 보면 결국 이전의 예시 코드처럼 assert 문을 여럿 사용하는 편이 좋다고 생각한다. 단, assert 문 개수는 최대한 줄여야 좋다.   

어쩌면 "테스트 함수마다 한 개념만 테스트하라"는 규칙이 더 낫겠다. 이것저것 잡다한 개념을 연속적으로 테스트하는 긴 함수는 피한다. 즉, assert 문이 여럿이라는 사실이 문제가 아니다. 한 테스트 함수에서 여러 개념을 테스트한다는 사실이 문제다. 그러므로 가장 좋은 규칙은 "개념 당 assert 문 수를 최소로 줄여라"와 "테스트 함수 하나는 개념 하나만 테스트하라"라 하겠다.

#### F.I.R.S.T
꺠끗한 테스트는 다음 다섯 가지 규칙을 따르는데, 각 규칙에서 첫 글자를 따오면 FIRST가 된다.

- **빠르게(Fast)**: 테스트는 빨라야 한다. 테스트는 빨리 돌아야 한다는 말이다. 테스트가 느리면 자주 돌릴 엄두를 못 낸다. 자주 돌리지 않으면 초반에 문제를 찾아내 고치지 못한다. 코드를 마음껏 정리하지도 못한다. 결국 코드 품질이 망가지기 시작한다.
- **독립적으로(Independent)**: 각 테스트는 서로 의존하면 안 된다. 한 테스트가 다음 테스트가 실행될 환경을 준비해서는 안 된다. 각 테스트는 독립적으로 그리고 어떤 순서로 실행해도 괜찮아야 한다. 테스트가 의존하면 하나가 실패할 때 나머지도 잇달아 실패하므로 원인을 진단하기 어려워지며 후반 테스트가 찾아내야 할 결함이 숨겨진다.
- **반복가능하게(Repeatable)**: 테스트는 어떤 환경에서도 반복 가능해야 한다. 실제 환경, QA 환경, 버스를 타고 집으로 가는 길에 사용하는 (네트워크에 연결되지 않은) 노트북 환경에서도 실행할 수 있어야 한다. 테스특 돌아가지 않는 환경이 하나라도 있다면 테스트가 실패한 이유를 둘러댈 변명이 생긴다. 게다가 환경이 지원되지 않기에 테스트를 수행하지 못하는 상황에 직면한다.
- **자가검증하는(Self-Validating)**: 테스트는 부울(bool)값으로 결과를 내야 한다. 성공 아니면 실패다. 통과 여부를 알려고 로그 파일을 읽게 만들어서는 안 된다. 테스트가 스스로 성공과 실패를 가늠하지 않는다면 판단은 주관적이 되며 지루한 수작업 평가가 필요하게 된다.
- **적시에(Timely)**: 테스트는 적시에 작성해야 한다. 단위 테스트는 테스트하려는 실제 코드를 구현하기 직전에 구현한다. 실제 코드를 구현한 다음에 테스트 코드를 만들면 실제 코드가 테스트하기 어렵다는 사실을 발견할지도 모른다. 어떤 실제 코드는 테스트하기 너무 어렵다고 판명날지 모른다. 테스트가 불가능하도록 실제 코드를 설계할지도 모른다.

> 테스트 코드는 지속적으로 깨끗하게 관리하자. 표현력을 높이고 간결하게 정리하자. 그러면 그만큼 테스트 코드를 짜기가 쉬워진다.   
> 테스트 API를 구현해 도메인 특화 언어(DSL)를 만들자. 그러면 그만큼 테스트 코드를 짜기가 쉬워진다. 테스트 코드를 깨끗하게 유지하자.
