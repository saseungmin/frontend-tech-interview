## 👉 Web

### 🎈 [CORS는 왜 이렇게 우리를 힘들게 하는걸까?](https://github.com/saseungmin/frontend-tech-interview/tree/main/web/cors)

### 🎈 [브라우저의 동작 원리](https://github.com/saseungmin/frontend-tech-interview/tree/main/web/%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80%EC%9D%98%20%EB%8F%99%EC%9E%91%20%EC%9B%90%EB%A6%AC)

### 🎈 CSR vs SSR
모바일 시대가 도래했고 모바일 환경에 맞춰진 웹 페이지에 대한 니즈가 폭발적으로 증가했고 그에 따른 성능 이슈도 함께 거론되었습니다. 데스크탑에 비해 성능이 낮은 모바일, 스마트폰을 통해 웹페이지를 출력하기 위해서 기존에 있었던 방식과 다른 접근이 필요했습니다. 그렇게 나온게 SPA 기법이 등장하게되었습니다. SPA는 브라우저에 로드되고 난 뒤에 페이지 전체를 서버에 요청하는 것이 아니라 최초 한번 페이지 전체를 로딩한 이후 부터는 데이터만 변경하여 사용할 수 있는 웹 어플리케이션입니다. 이전에 요청 시 마다 새로고침이 일어나며 페이지를 로딩할 때마다 서버로부터 리소스를 전달받아 해석하고 화면에 렌더링하는 방식은 MPA 방식입니다. SPA는 트래픽을 감소시키고 사용자에게 더 나은 경험을 재공ㅇ했습니다. 서버는 단지 JSON 파일만 보내주는 역할을 헀고, Html을 그리는 역할은 클라이언트 측에서 자바스크립트가 수행하게 된 것입니다. 이것이 바로 클라이언트 사이드 렌더링입니다. 그런데 클라이언트 쪽이 점점 무거워지자 이에 반대로 view만 관리하자는 철학으로 React가 등장하게 되었고 이렇게 클라이언트 사이드 렌더링과 서버 사이드 렌더링의 싸움이 시작된 것입니다.   

클라이언트 사이드 렌더링의 경우, 사용자의 행동에 따라 필요한 부분만 다시 읽어들이기 때문에 서버 측에서 렌더링하여 전체 페이지를 다시 읽어들이는 것보다 빠른 인터렉션을 기대할 수 있습니다. 하지만, 클라이언트 사이드 렌더링은 페이지를 읽어오는 시간, 자바스크립트를 읽어들이는 시간, 자바스크립트를 화면에 그리는 시간까지 모두 마쳐야 콘텐츠가 사용자에게 보여지게 됩니다. 즉, 초기 구동 속도가 느리다는 단점이 존재합니다. 그리고 가장 치명적인 단점은 검색 엔진 최적화의 문제가 존재한다는 점입니다. 대부분의 웹 크롤러, 봇들이 자바스크립트 파일을 실행시키지 못하기 때문입니다.   

반대로 서버사이드 렌더링인 경우 JS를 이용한 렌더링이 아니기 떄문에 검색 엔진에 최적화가 가능하고, 초기 로딩은 빠르지만, 매번 페이지 요쳥떄마다 새로고침이 되기 때문에 사용자 경험이 SPA보다 좋지 못하고, 매번 요청을 하기 때문에 서버의 부하가 커집니다.   

### 🎈 [프론트엔드 렌더링: SSG vs ISG vs SSR vs CSR - 언제 어떤 것을 사용해야 할까요?](https://tapajyoti-bose.medium.com/frontend-rendering-ssg-vs-isg-vs-ssr-vs-csr-when-to-use-which-1bf9f39ff07c)

#### 정적 페이지 생성 (SSG, Static Site Generation)
SSG는 raw 데이터와 템플릿 세트를 바탕으로 완전히 정적인 HTML 웹 사이트를 생성하는 방법입니다. 기본적으로 정적 사이트 생성은 각각의 HTML 페이지 코딩 작업을 자동화하고 해당 페이지를 미리 사용자에게 제공할 수 있도록 준비합니다. 간단히 말해서, SSG는 웹 사이트의 모든 페이지를 미리 렌더링하고 클라이언트 요청에 따라 페이지를 제공합니다.   

장점 
1. SSG는 데이터베이스 또는 서버 측 프로세스가 거의 필요하지 않은 완전히 정적인 HTML 기반 사이트를 생성할 수 있는 기능을 제공합니다.
2. 정적 사이트는 미리 만들어져 사용자에게 제공될 준비가 되어 있기 때문에 가장 빠른 형식의 웹 페이지입니다.
3. 웹사이트가 미리 만들어졌기 때문에 콘텐츠가 훨씬 더 안전합니다.
4. 검색 엔진 최적화(SEO)에 유리합니다.

단점
1. 콘텐츠를 편집하고 올리는 것이 어렵습니다. 편집자들은 단순한 웹 앱 인터페이스가 아닌 Git 저장소의 접근 권한을 요구할 수 있습니다.
2. 콘텐츠를 업데이트하려면 사이트를 다시 빌드하고 테스트한 후 최종적으로 배포해야 합니다.
3. 대규모 웹 사이트의 경우 빌드가 오래 걸리는 것은 말할 것도 없고, 관리하는 것도 매우 번거롭습니다.

SSG는 장점이 많지만 제품 쇼케이스 웹사이트처럼 내용이 거의 변하지 않는 웹사이트인 경우에만 사용해야 합니다.   
블로그의 경우, 수정할 때마다 사이트를 다시 배포해도 괜찮다면 SSG를 사용할 수 있습니다.   
약간의 동적인 콘텐츠라도 포함하고 있는 사이트라면 SSG를 절대 사용하지 마세요.


#### 서버 사이드 렌더링 (SSR, Server-Side Rendering)
서버 사이드 렌더링(SSR)은 브라우저에서 웹 페이지를 렌더링하는 대신 서버에서 웹 페이지를 생성하는 방법입니다. 서버에서 완전히 렌더링 된 페이지를 클라이언트로 보냅니다. 클라이언트의 자바스크립트 번들이 SPA 프레임워크의 작동을 대신합니다.   

SSR에서는 페이지가 서버에서 렌더링 되어 클라이언트로 전송되기 때문에 동적 데이터를 사용하면서도 여전히 우수한 SEO를 유지할 수 있습니다.

장점
1. 동적 콘텐츠가 포함된 페이지를 만드는 데 사용할 수 있습니다.
2. SSR은 SSG만큼 빠르지는 않지만 페이지가 로드되는 즉시 콘텐츠가 나타나므로 유저가 빠르게 콘텐츠를 확인할 수 있습니다.
3. 검색 엔진 최적화(SEO)에 유리합니다.

단점
1. SSR은 모든 요청이 서버에서 처리되기 때문에 서버에 높은 연산 능력을 필요로 합니다.
2. SSR 사이트는 공격할 수 있는 지점이 더 많으므로 보안을 유지하기가 더 어렵습니다.
3. 캐싱에 복잡한 구성이 많이 필요합니다.

SSR은 서버 비용을 크게 증가시킬 가능성이 있으므로, 매우 빈번하게 변경되고 SEO에 크게 의존하는 매우 동적인 콘텐츠를 포함하고 있는 사이트인 경우에만 사용해야 합니다. 예를 들어 오가닉(organic) 검색에서 사용자를 모으는 주식 시세 표시기 웹사이트라면 SSR이 필요합니다.

#### 점진적 정적 재생성 (ISR, Incremental Static Regeneration)
점진적 정적 재생성(ISR)을 사용하면 전체 사이트를 재빌드할 필요 없이 페이지별로 정적 생성을 사용할 수 있습니다. ISR을 사용하면 정적 사이트의 이점을 유지하면서 수많은 페이지로 확장할 수 있습니다.   

ISR은 SSG와 SSR의 장점이 합쳐져 보다 효율적이고 확장 가능한 솔루션을 제공하기 때문에 매우 효과적입니다.   

장점
1. SSG와 동일하게 ISR도 페이지를 미리 렌더링하고 캐시하기 때문에 매우 굉장히 빠릅니다.
2. 내용 변경되어도 사이트를 다시 배포할 필요가 없습니다.
3. 검색 엔진 최적화(SEO)에 유리합니다.

단점
1. ISR에는 한 가지 큰 단점이 있는데, 콘텐츠가 변경된 후에 사이트를 방문하게 되어도 이전의 콘텐츠를 보게 됩니다. 새 버전의 웹사이트는 아직 확인할 수 없습니다.

ISR은 이상적으로는 콘텐츠가 동적이지만 자주 변경되지 않는 사이트인 경우 ISR을 사용하는 것이 좋습니다. 그 예시로는 블로그나 개인 웹사이트가 있습니다.

#### 클라이언트 사이드 렌더링 (CSR, Client-Side Rendering)
클라이언트 사이드 렌더링(CSR)은 자바스크립트를 사용하여 브라우저에서 직접 페이지를 렌더링하는 것을 의미합니다. 모든 로직, 데이터 페칭, 템플릿 및 라우팅은 서버가 아닌 클라이언트에서 처리됩니다.   

CSR에서 서버는 빈 HTML 페이지와 모든 로직을 처리하는 자바스크립트 번들을 반환합니다.

장점
1. 동적 콘텐츠가 포함된 페이지를 만드는 데 사용할 수 있습니다.
2. SSG와 달리 서버 비용이 높지 않습니다.
3. 처음 로드한 후 다른 페이지를 로드하는 속도가 매우 빠릅니다.

단점
1. 검색 엔진 최적화(SEO)가 잘되지 않습니다.
2. 느린 초기 로드 시간과 상호 작용하기 위한 시간이 성능 저하를 일으킵니다.

CSR은 SEO에 크게 의존하지 않는 모든 사이트에 이상적입니다. Tauri 또는 Electron과 같은 도구를 사용하여 풍부한 사이트 상호작용과 웹, 크로스 플랫폼 어플리케이션을 만드는 데 사용할 수 있습니다.

### 🎈 브라우저 렌더링 과정 (Critical Rendering Path)
우리가 주소창에 url를 입력하고, 브라우저는 해당 서버로 요청을 보내고 서버에는 응답으로 HTML 데이터를 내려주는데, 이 HTML 데이터를 실제 우리가 보이는 화면으로 그리기까지 단계를 critical rendering path라고 부릅니다.   
1. 서버에서 응답을 받은 HTML 데이터를 파싱을 합니다. 이때 javascript 파일을 만나면 해당 파일을 받아오고 실행할 떄까지 파싱을 멈춥니다.
2. 이 HTML 파싱한 결과로 DOM Tree를 만듭니다.
3. 파싱하는 중 CSS 파일 링크를 만나면 CSS 파일을 요청해서 받아옵니다.
4. CSS 파일을 읽어서 CSSOM을 만듭니다.
5. DOM Tree와 CSSOM이 모두 만들어지면 이 둘을 사용해 Render Tree를 만드는데 이 Render Tree는 실제로 눈에 보이는 친구들로만 이루어집니다.
6. Render Tree에 있는 각각의 노드들이 화면의 어디에 어떻게 위치할 것인가를 계산하는 Layout 과정을 거치는데 만약 브라우저 창이 변경되면 Render Tree를 만드는 과정은 생략되고, Layout이 일어나게 됩니다.
7. 이제 Render Tree 각 노드들을 실제로 화면에 그리게 되는 Paint 과정을 거치게 됩니다.

### 🎈 Reflow or Repaint(or ReDraw)과정 설명 및 최적화 방법
reflow는 생성된 DOM 노드의 레이아웃 수치 변경시 영향을 받은 모든 노드 수치를 다시 계산하여 렌더트리를 재생성하는 과정입니다. reflow과정이 끝난 뒤 렌더 트리를 다시 그리는 과정을 repaint라고 합니다.   
다음과 같은 코드가 이제 reflow가 발생합니다.

```js
function reflow () {
  document.getElementById('container').style.width = '600px';
  return false;
}
```
변경딘 스타일 수치 계산이 수행되고, reflow 과정이 수행되고 생성된 렌더 트리를 그리는 repaint과정이 수행됩니다.

repaint 발생은 이유야 background-color같은 경우는 레이아웃 수치는 변경되지 않았으므로 reflow과정이 생략된 repaint 과정만 일어나게 됩니다.

### 🎈 CORS
웹에서 다른 출처로의 리소스 요청을 제한하는 것과 관련된 두 가지 정책이 존재하는데 하나가 CORS고 하나가 SOP입니다. CORS는 서로다른 출처끼리의 리소스를 공유하는 정책이고 SOP는 서로다른 출처끼리의 리소스를 공유하지 못하게 하는 정책입니다. 이러한 정책이 존재하는 이유는 보안적인 문제 때문인데 아무런 제약이 없으면 악의를 가진 사용자가 소스코드를 본 후 CSRF와 XSS와 같은 방법을 사용하여 정보를 탈취할 수 있다.   

클라이언트가 다른 출처의 리소스를 요쳥할 때는 HTTP 프로토콜을 사용하여 요청을 보내게 되는데, 이때 브라우저는 요청 헤더에 Origin이라는 필드에 요청을 보내는 출처를 함께 담아보냅니다. 이후 서버가 이 요청에 대한 응답을 할 때 응답 헤더에 Access-Control-Allow-Origin 이라는 값에 이 리소스를 접근하는 것이 허용된 출처를 내려주고, 이후 응답을 받은 브라우저는 요청의 Origin과 서버가 보내준 응답의 Access-Control-Allow-Origin을 비교해본 후 이 응답이 유효한 응답인지 아닌지를 결정하게 됩니다.

### 🎈 local storage vs session storage vs cookie
모든 클라이언트 상에서 key/value 형태로 저장할 수 있는 메커니즘으로 value는 반드시 문자열이어야 합니다. 또한 모두 동일 출처 정책을 따르기 떄문에 다른 도메인에서 접근할 수 없습니다.   

쿠키는 클라이언트 또는 서버에 의해서 생성되며 지속시간을 설정에 따라 다릅니다. 용량은 5kb정도이며 서버와의 통신이 가능하지만 취약점으로 XSS/CSRF 공격이 존재합니다. 하지만, 저의 경험상 httponly 속성을 true로 변경하고, security 속성을 true로 변경해서   
local storage는 클라이언트에서 생성되며 명시적으로 삭제할떄까지 유지가 됩니다. 용량은 5mb에서 10mb정도이며 서버와의 통신은 불가능하고 취약점으로는 XSS 공격이 존재합니다.   
session storage도 마찬가지로 클라이언트에서만 생성할 수 있고 같은 취약점이 존재하지만 다른점으로는 브라우저가 종료되면 삭제가 됩니다.

### 🎈 XSS와 CSRF
XSS(Cross Site Scription)는 권한이 없는 사용자가 웹 사이트에 스크립트를 삽입하는 공격 방법으로 악의적으로 스크립트를 삽입하여 이를 열람한 사용자의 쿠키가 해커에게 전송시키며, 이 탈취한 쿠키를 통해 세션을 하이제킹합니다. 그로인해서 세션 ID를 가진 쿠키로 사용자의 계정으로 로그인이 가능해지는 겁니다.   

CSRF(Cross Site Request Forgery) 인터넷 사용자가 자신의 의지와는 무관하게 공격자가 의도한 행위를 특정한 웹사이트에 request하도록 만드는 공격을 말하는데 유저의 권한을 도용합니다. 보통 사용자가 해커가 만든 피싱 사이트에 접속하거나, 위조 요청을 전송하는 서비스에 사용자가 로그인한 상황등이 있습니다.

### 🎈 프레임워크와 라이브러리의 차이점
프레임워크는 구조나 뼈대같은 것을 의미하는데, 라이브러리는 가져다가 사용할 수 있는 도구와 관련이 있습니다. 이 둘의 차이점은 제어의 주체가 어디에/누구에 있느냐가 중요한데, 프레임워크는 전체적인 흐름을 스스로 쥐고 있으며 사용자는 그 정해진 틀에 맞춰서 (안에 들어가서) 코드를 짜 넣는 것입니다. 라이브러리는 제어의 주체는 사용자가 쥐고 있으며 그 흐름을 직접 만드는 것입니다. 예를 들어, 라이브러리는 톱, 삽, 망치 같은 연장을 비유할 수 있는데, 톱, 삽, 망치같은 것들은 자신이 원하는 도구를 마음대로 선택해서 결과물을 만들 수 있는 것이고, 프레임워크는 배, 차, 비행기같은 탈것에 비유할 수 있겠는데, 배, 차 비행기는 각자의 목적에 맞게 (배는 바다, 비행기는 하늘, 차는 땅)사용해야 하며, 차를 사용할 경우 기어, 패달등 사용법을 알면 내가 만들 필요 없이 목적에 맞게 사용할 수 있습니다.

### 🎈 Webpack이란 무엇인가?
웹 사이트를 구성할 때 js, css, images 파일등 수 많은 파일들이 모여 웹사이트를 구성하게 됩니다.   
따라서 웹 사이트에 접속했을 때 굉장히 많은 파일이 다운로드될 수 있는데 이것에 비례하여 서버의 자원을 소모하고 웹사이트가 느리게 로딩됩니다.   
또한, 많은 자바스크립트 패키지등을 사용하다보면 각각의 서로의 다른 패키지들이 서로 같은 이름이나 함수를 사용하게 되면서 애플리케이션이 깨지게 되는데 이러한 현상을 해결하기 위해 나온 개념이 묶는다는 개념의 번들러가 등장하게 되었습니다.   

webpack, broserify, parcel등과 같은 도구들이 번들러에 속합니다.   

**웹팩은 모던 자바스크립트 애플리케이션을 위한 정적 모듈러입니다.**   
모듈 번들러란 웹 애플리케이션을 구성하는 자원(HTML, CSS, JavaScript, images 등)을 모두 각각의 모듈로 보고 이를 조합해서 병합된 하나의 결과물을 만드는 도구를 의미합니다. 간단하게 표현하자면 웹팩이란 여러 파일을 하나 이상의 파일로 합쳐주는 자바스크립트 번들러입니다.   

이러한 웹팩은 왜 등장하게 되었을까요?   
위에서 언급하였듯 수 많은 파일이 모여 하나의 웹 사이트를 구성하게 됩니다. 인터넷의 발전으로 웹 어플리케이션의 복잡도가 증가하면서 자바스크립트의 코드의 양이 방대해지고 이러한 코드를 쉽게 유지보수하기 위해 모듈로서 관리하는 방법이 필요하게 되었습니다.   
자바스크립트에서는 ES2015(ES6) 이전에는 모듈로서 관리하는 방법으로 AMD, CommonJS등이 존재하였으나 하나의 표준이 아닌 사용하는 사람에 따라 원하는 것을 선택하는 방식으로 사용해왔습니다.   
그 후, ES6 이후부터 자바스크립트에서 표준 모듈 시스템을 제안하였고 이것이 `export/import` 방식입니다.   

그러나, **모든 브라우저에서 ES6 방식의 모듈 시스템을 지원하지는 않았습니다.** 따라서 **개발자들은 브라우저와 버전에 상관없이 편리한 모듈 시스템을 사용하기를 원했고, 이러한 배경에 의해 등장하게된 툴이 웹팩입니다.**   

조금 더 세분화하자면 웹팩의 등장 배경을 아래와 같이 정리할 수 있습니다.
1. 파일 단위의 자바스크립트 모듈 관리의 필요성
2. 웹 개발 작업 자동화 도구(Web Task Manager)
3. 웹 애플리케이션의 빠른 로딩 속도와 높은 성능

웹팩에서 지칭하는 모듈은 자바스크립트 모듈 뿐만이 아닌 HTML, CSS, JavaScript, Images, Font등 모든 파일 하나하나 모듈이라 지칭하며 웹 애플리케이션을 구성하는 모든 자원을 모듈이라 보면 됩니다. 보통 모듈 번들링에서는 빌드, 번들링, 변환 이 세 단어는 모두 같은 의미로 사용됩니다.   

웹팩으로 해결하려는 문제
1. 자바스크립트 변수 유효 범위 문제
  - ES6의 모듈 문법과 번들링으로 해결
2. 브라우저별 HTTP 요청 숫자의 제약
  - 웹팩은 여러 파일을 하나 이상의 파일로 합쳐 맨 처음 언급하였던 서버로부터 파일을 다운로드 받는 횟수가 줄어들게 되고 이 효과로 인해 브라우저별 HTTP 요청 숫자 제약을 피할 수 있습니다.
3. 사용하지 않는 코드의 관리
4. Dynamic Loading 및 Lazy Loading 미지원 문제
  - 이전에 Require.js와 같은 라이브러를 사용하지 않는 이상 동적으로 원하는 순간에 모듈을 로딩하는 것이 불가능했습니다. 웹팩에서는 Code Splitting 기능을 이용하여 원하는 모듈을 원하는 타이밍에 로딩할 수 있습니다.
